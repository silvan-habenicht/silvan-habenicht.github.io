<!DOCTYPE html>
<html lang="de">

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>BendisPasta | Lernplattform für Design Patterns</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="main.css">
        <link rel="stylesheet" href="javascript/styles/school-book.css">
        <link rel="icon" type="image/jpg" href="pictures/pasta_small.png"/>
    </head>

    <body id="main">

        <!-- syntax highlighting -->
        <script src="javascript/highlight.pack.js"></script>
        
        <!-- website appearance -->
        <script src="script.js"></script>
        
        <!-- multiple choice test evaluation -->
        <script src="check-test.js"></script>
        
        <audio src="audio/tinder-message.mp3" type="audio/mpeg"></audio>
        
        <!-- pop-up notification -->
        <div id="alert">
            <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span> 
            Gratulation! Du kannst jetzt dein Zertifikat herunterladen
        </div>

        <!-- sidebar menu -->
        <div class="sideMenu" id="patternMenu">
            <img src="pictures/pasta_medium.png" alt="Logo">
            <a id="titleMenu" style="font-weight:bold;box-shadow: none;font-style:normal;">Pattern-Menü</a>
            <a id="adapterMenu" style="text-indent:15px;font-size:14px;"href="#adapter"onclick="conditionCloseMenu()">Adapter</a>
            <a id="commandMenu" style="text-indent:15px;font-size:14px;" href="#command"onclick="conditionCloseMenu()">Command</a>
            <a id="factoryMenu" style="text-indent:15px;font-size:14px;"href="#factory"onclick="conditionCloseMenu()">Factory</a>
            <a id="decoratorMenu" style="text-indent:15px;font-size:14px;"href="#decorator"onclick="conditionCloseMenu()">Decorator</a>
            <a id="strategyMenu" style="text-indent:15px;font-size:14px;"href="#strategy"onclick="conditionCloseMenu()">Strategy</a>
            <a id="observerMenu" style="text-indent:15px;font-size:14px;"href="#observer"onclick="conditionCloseMenu()">Observer</a>
            <a id="mvcMenu" style="text-indent:15px;font-size:14px;"href="#mvc"onclick="conditionCloseMenu()">MVC</a>
            <br/>
            <button type="button" style="width: auto;" disabled=true onclick="getCertificate()" id="certificate">Zertifikat erstellen</button>
            <br/>
            <br/>
            <br/>
        </div>

        <!-- sidebar menu icon -->
        <div class="menuIcon">
            <a id="toggle" onclick="openCloseMenu()"><span></span></a>
        </div>

        <!-- title + welcoming text -->
        <div>
            <hr class="italian" />
            <h1>Ristorante BendisPasta</h1>
            <hr class="italian" />
            <h2>Willkommen in der Pizzeria BendisPasta!</h2>

            <p>
                Diese Website dient einem schmackhaften Einstieg in <em>Design Patterns</em> (zu Deutsch: Entwurfsmuster). Hierbei handelt es sich um allgemeine Entwurfsprinzipien, nach denen objektorientierter Softwarecode aufgebaut werden kann. Bei bestimmten wiederkehrenden Anwendungsfällen helfen diese dabei, dass der Code möglichst flexibel an veränderte Anforderungen angepasst oder um erweiterte Funktionalität ergänzt werden kann. Die Kenntnis grundlegender <em>Design Patterns</em> ist für die moderne OO-Entwicklung von elementarer Bedeutung.
            </p>

            <p>
                Im Folgenden wirst du einige der wichtigsten <em>Design Patterns</em> kennen und einzusetzen lernen. Wir werfen dazu einen Blick in die Arbeitswelt der traditionsreichen virtuellen Pizzeria <em>BendisPasta</em>. Ihr Geschäftführer Jens hat dort erst kürzlich angeordnet, die vorherrschenden Arbeitsabläufe nach dem Vorbild der agilen Softwareentwicklung zu modernisieren.
            </p>

        </div>
        
        <!-- Das Adapter-Pattern -->
        <div id="adapter">
            <h2>Das Adapter-Pattern <a class="testjump" href="#adapterForm">...direkt zum Test...</a></h2>
            
            <p class="note">
                Zur „Anpassung der Schnittstelle einer Klasse an ein anderes von den Clients erwartetes Interface. Das Design Pattern Adapter (Adapter) ermöglicht die Zusammenarbeit von Klassen, die ansonsten aufgrund der Inkompatibilität ihrer Schnittstellen nicht dazu in der Lage wären.“ [GoF]
            </p>
            
            <p>
                Im Restaurant <em>BendisPasta</em> werden in erster Linie zwei Arten von Objekten serviert: Gerichte und Getränke.      
            </p>
            
            <div style="display:flex; flex-wrap: wrap;">
                <div style="margin-left: auto;margin-right: auto;">
                <h4>Gerichte-API</h4>
                <pre><div class="code"><code>
interface Gericht {

    void zubereiten();
    void servieren();
    ...
  
}
                </code></div></pre>
                </div>
                <div style="margin-left: auto;margin-right: auto;">
                <h4>Getränke-API</h4>
                <pre><div class="code"><code>
interface Getraenk {

    void einschaenken();
    void servieren();
    ...
  
}
                </code></div></pre>
                </div>
            </div>
            
            <p>
                Bislang wurde die Methode <code>zubereiten()</code> ausschließlich von einer Instanz der Klasse <code>Koch</code> aufgerufen, das Einschänken der Getränke wurde hingegen von einem <code>Barkeeper</code>-Objekt übernommen. Im Zuge der betrieblichen Rationalisierungsmaßnahmen wird von den Mitarbeitern nun mehr Flexibilität verlangt. Um an besucherarmen Tagen effizienter zu arbeiten, sollen alle Mitarbeiter, die bislang nur mit Gerichten zu tun hatten, auch mit Getränken umgehen können.
            </p>
            
            <h4>Was ist zu tun?</h4>
            <p>
                Im Kern machen die beiden Methoden <code>zubereiten()</code> und <code>einschaenken()</code> dasselbe: Sie bereiten eine Bestellung so vor, dass sie vom Kellner serviert werden kann. Wann immer ein Koch auf einem Gerichte-Objekt <code>zubereiten()</code> aufrufen würde, müsste er also anstelle dessen <code>einschaenken()</code> aufrufen, sofern er es mit einem Getränk zu tun hat. Eine Möglichkeit das zu realisieren besteht in einem Refactoring. Wir könnten z. B. alle Klassen so anpassen, dass <code>Gericht</code> und <code>Getraenk</code> sowie <code>Koch</code>, <code>Barkeeper</code> und alle anderen Mitarbeiter nur noch mit einer einheitlichen Methode (z. B. <code>vorbereiten()</code>) arbeiten. Der Refactoring Ansatz ist jedoch mit hohem Aufwand verbunden, falls die bisherigen Methodennamen und Strukturen schon vielfach genutzt wurden und verstreut im Einsatz sind.
            </p>
            
            <h4>Die Lösung</h4>
            <p>
                Eine schnelle und einfach Lösung des Problems besteht darin, das Adapter-Pattern zu nutzen. Unten siehst du eine Getränke-Adapter-Klasse, die es dem Koch ermöglicht, ein Getränk genau so zu behandeln, wie er es von seinen Gerichten gewohnt ist:
            </p>
            
            
            <pre><div class="code"><code>
class GetraenkeAdapter implements Gericht {

    Getraenk getraenk;

    public GetraenkeAdapter(Getraenk getraenk) {
        this.getraenk = getraenk;
    }

    void zubereiten() {
        getränk.einschaenken();
    }

    void servieren() {
        getränk.servieren();
    }
    ...

}
            </code></div></pre>
        
        
            <p>
                Wann immer wir unserem Koch also ein Getränk übergeben möchten, stecken wir es vorher in einen Getränkeadapter. Wenn wir beispielsweise möchten, dass sich unser Koch um ein Wasser kümmert, so schreiben wir ihm anstelle von <code>new Wasser</code> folgendes auf Aufgabenliste: <code>new GetraenkeAdapter(new Wasser())</code>. Wir erzeugen also ein Objekt der Klasse <code>GetraenkeAdapter</code>, welchem wir im Konstruktor ein Getränk übergeben. Der Getränke-Adapter kümmert sich darum, die Funktionen der Getränke-Klasse in ihre Entsprechungen aus der Gerichte-Klasse zu übersetzen. Da <code>GetraenkeAdapter</code> eine Unterklasse von <code>Gericht</code> ist, sind keine weiteren Änderungen in der <code>Koch</code>-Klasse erforderlich.
            </p>
            
            <h4>Ein Praxisbeispiel</h4>
            <p>
                Wenn du schon eine Weile mit Java gearbeitet hast, wird dir das Interface <code>java.util.Iterator</code> vielleicht ein Begriff sein. Die Schnittstelle beinhaltet die Funktionen <code>hasNext()</code>, <code>next()</code> sowie <code>remove()</code> und löst damit ihren Vorgänger <code>java.util.Enumeration</code> ab. Die beiden Methoden der Enumeration-Schnittstelle sind <code>hasMoreElements()</code> und <code>nextElement()</code>. Es kann durchaus vorkommen, dass wir in einem alten Java-Projekt auf Enumerations stoßen, obwohl wir inzwischen Iterators verwenden. In einem solchen Fall würde es sich anbieten, mit einem Enumeration-Adapter zu arbeiten.
            </p>
            
            <p class="note">
                Übrigens: Auch der Iterator ist ein sogenanntes Design Pattern. Zweck des Iterator-Patterns ist es, den Zugriff auf Objekte einer Collection zu ermöglichen, ohne die zugrunde liegende Implementierung zu kennen.
            </p>
        
            <form id="adapterForm">
                <h3>Zwischenprüfung</h3>
                <fieldset>
                    Was ist die Aufgabe des Adapter-Patterns?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="adapterA">
                                Transformation von angloamerikanischen Maßeinheiten in das metrische System und umgekehrt
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="adapterA">
                                Refactoring
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="adapterA" >
                                Es reduziert eine Schnittstelle auf die Elemente, die ein bestimmter Client benötigt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="adapterA">
                                Übersetzung der Schnittstelle einer bestimmten Klasse in die Schnittstelle einer ähnlich gearteten anderen Klasse
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welches Objekt wird der Adapter-Klasse im Konstruktor übergeben?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="adapterB">
                                Das Objekt, dessen Schnittstelle für den Client übersetzt werden muss
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="adapterB">
                                Das Objekt, dessen Schnittstelle der Client erwartet
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="adapterB">
                                Das <code>null</code>-Objekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="adapterB">
                                Das Client-Objekt
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Ergänze den nachfolgenden Code-Ausschnitt. Zur Erinnerung: Das Interface <code>Iterator</code> besitzt die drei Methoden <code>hasNext()</code>, <code>next()</code> sowie <code>remove()</code>. Das Interface <code>Enumeration</code> hat lediglich die beiden Funktionen <code>hasMoreElements()</code> und <code>nextElement()</code>.
                </fieldset>
                <pre><div class="code"><code>
class EnumerationAdapter implements Iterator&lt;E&gt; {

    Enumeration&lt;?&gt; enumeration;

    public EnumerationAdapter(Enumeration&lt;?&gt; enumeration) {
        this.enumeration = enumeration;
    }

    public boolean <input type="text" value = "hasNext()" style="width: 9ch;" name="adapterC1"> { // Bitte vervollständigen
        return <input type="text" value="enumeration.hasMoreElements()" style="width: 29ch;" name="adapterC2">; // Bitte vervollständigen
    }

    public E next() {
        return <input type="text" value="enumeration.nextElement()" style="width: 25ch;" name="adapterC3">; // Bitte vervollständigen
    }
    
    public void <input type="text" value="remove()" style="width: 8ch;" name="adapterC4"> { // Bitte vervollständigen
        throw new UnsupportedOperationException();
    }
    
}
                </code></div></pre>
                <button type="button" onclick="checkAdapter('adapter')" id="adapterButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="adapterResult"></center>
            </form>
        </div>

        <!-- Das Command-Pattern -->
        <div id="command">
            <h2>Das Command-Pattern <a class="testjump" href="#commandForm">...direkt zum Test...</a></h2>
            
            <p class="note">
                Zur „Kapselung eines Requests als Objekt, um so die Parametrisierung von Clients mit verschiedenen Requests, Warteschlangen- oder Logging-Operationen sowie das Rückgängigmachen von Operationen zu ermöglichen.“ [GoF]
            </p>
            
            <p>
                In letzter Zeit gab es mehrere Beschwerden von Kunden des Ristorante Bendispasta, die etwa versucht haben bei einem Koch ein Getränk zu bestellen. Sie wurden barsch zurückgewiesen mit Aussagen wie „Dafür bin ich nicht zuständig!“ oder „Jetzt nicht!“. Ein Ähnliches verhalten legten auch andere Mitarbeiter an den Tag. Viele Kunden sind verunsichert, an wen Sie sich mit Ihren Bestellwünschen wenden sollen. 
            </p>
            
            <h4>Was ist zu tun?</h4>
            
            <p>
                Unser Geschäftsführer Jens schlägt vor, die ausführenden Mitarbeiter von den Kunden zu entkoppeln. Jegliche Bestellung soll nur noch über einen Vermittler, den Kellner, abgewickelt werden. Dem Kunde kann egal sein auf welchem Wege sein Gericht zubereitet, sein Getränk einschänkt oder ihm eine <a target="_blank" href="https://www.youtube.com/watch?v=XFj45oeA7bE" >saubere Gabel</a> gebracht wird &mdash; Ansprechpartner soll in allen Fällen der Kellner sein.
            </p>
            
            <h4>Die Lösung</h4>
            
            <p>
                An dieser Stelle bedienen wir uns dem Command-Pattern, welches sich in vier Klassen und ein Interface gliedert: Es gibt den Kunden (<em>Client</em>), den Empfänger (<em>Receiver</em>), den Aufrufer (<em>Invoker</em>) und den konkreten Befehl (<em>concrete Command</em>), der ein Interface vom Typ Befehl (<em>Command</em>) implementiert. Dieses Interface, enthält eine einzige Methode <code>ausfuehren()</code> bzw. <code>execute()</code>:
            </p>

            <pre><div class="code"><code>
interface Befehl {
    void ausfuehren();
}

            </code></div></pre>
            
            <p>
                Der Ablauf in einem Command-Pattern sieht in etwa wiefolgt aus: Der Kunde erzeugt zunächst ein konkretes Befehls-Objekt und benennt darin den Empfänger (das Objekt, welches den Befehl am Ende ausführen soll/kann). Der Aufrufer nimmt das Befehls-Objekt entgegen, speichert es und ruft bei Gelegenheit dessen ausfuehren()-Methode auf. Diese wiederum ruft den Empfänger auf, der schließlich den eigentlichen Befehl ausführt. Sehen wir uns einmal an, wie so eine konkrete Befehls-Klasse aussehen könnte. Der Empfänger ist in diesem Fall ein Gericht:
            </p>
            
            <pre><div class="code"><code>
class GerichteBestellung implements Befehl {

    Gericht gericht;

    public GerichteBestellung (Gericht gericht) {
        this.gericht = gericht;
    }

    void ausfuehren() {
        gericht.zubereiten();
        gericht.servieren();
    }

} 
            </code></div></pre>
            
            <p>
                Nun werfen wir einen Blick auf die Kellner-Klasse, welche in unserem Beispiel als Aufrufer fungiert. Nachdem der Kunde einen konkreten Befehl erzeugt hat, kann er ihn dem Kellner in der Methode <code>bestellungEntgegennehmen(Befehl befehl)</code> übergeben. Dieser wird dann später alle Befehle ausführen lassen.
            </p>
            
            <pre><div class="code"><code>
class Kellner {

    List&lt;Befehl&gt; bestellung;

    public Kellner () {
        bestellung = new ArrayList&lt;Befehl&gt;();
    }

    void bestellungEntgegennehmen(Befehl befehl) {
        bestellung.add(befehl);
    }
    
    void bestellungAbschliessen() {
        for(Befehl b : bestellung) {
            b.ausfuehren();
        }
    }

} 
            </code></div></pre>
    
            <form id="commandForm">
                <h3>Zwischenprüfung</h3>
                <fieldset>
                    Was macht das Command-Pattern?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="commandA">
                                Es kontrolliert eine größere Anzahl verwandter Klassen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="commandA">
                                Es überwacht die main-Methode
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="commandA">
                                Es kapselt einen Auftrag in ein Objekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="commandA">
                                Es sortiert eine Menge von Befehlen
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Wie heißt üblicherweise die Methode, die von einer konkreten Command-Klasse implementiert werden muss?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="commandB">
                                <code>command()</code>
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="commandB">
                                <code>transfer()</code>
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="commandB">
                                <code>deploy()</code>
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="commandB">
                                <code>execute()</code>
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkCommand('command')" id="commandButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="commandResult"></center>
            </form>
        </div>
        
        <!-- Das Factory-Pattern -->
        <div id="factory">
            <h2>Das Factory Method-Pattern <a class="testjump" href="#factoryForm">...direkt zum Test...</a></h2>
            
            <p class="note">
                Zur „Definition einer Schnittstelle zur Objekterzeugung, wobei die Bestimmung der zu instanziierenden Klasse den Unterklassen überlassen bleibt. Das Design Pattern Factory Method (Fabrikmethode) gestattet einer Klasse, die Instanziierung an Unterklassen zu delegieren.“ [GoF]
            </p>
            
            <p>
                Bislang war es so, dass der Kunde zunächst wissen musste, wie er ein bestimmtes Gericht erzeugt, ehe er dieses in Form einer <code>GerichteBestellung</code> in Auftrag geben konnte. Eigentlich ist das nicht die Aufgabe des Kunden und sollte ein Geheimnis der Küche bleiben. Der Kunde hat eine Menükarte, in dem die einzelnen Gerichte mit Nummern versehen aufgelistet sind. Wir möchten daher unsere Befehls-Klassen dahingehend ändern, dass die Zuständigkeit der Gericht-Instanziierung nicht mehr beim Kunden liegt.
            </p>
            
            <h4>Was ist zu tun?</h4>
            
            <p>
                Anstelle konkreter Menü-Objekte, wollen wir den Befehlsklassen in Zukunft die entsprechenden Nummern aus der Karte übergeben. Die neue <code>GerichteBestellung</code>-Klasse könnte in etwa so aussehen:
            </p>
            

            <pre><div class="code"><code>
class GerichteBestellung implements Befehl {

    Gericht gericht;

    public GerichteBestellung(int gerichtID) {

        if(gerichtID == 1) {
            gericht = new InsalataMista();
        } else if (gerichtID == 2) {
            gericht = new InsalataCapricciosa();
        }

        ...

        else if (gerichtID == 35) {
            gericht = new PizzaMargherita();
        } else if (gerichtID == 36) {
            gericht = new PizzaCipolla();
        } else if (gerichtID == 37) {
            gericht = new PizzaCalzone();
        }

        ...

        else if (gerichtID == 68) {
            gericht = new PenneAllArrabiata();
        }

        ...

    }

    void ausführen() {
        gericht.zubereiten();
        gericht.servieren();
    }

}
            </code></div></pre>
            
            <p>
                Wie du vielleicht schon erkannt hast, ist diese Art der Implementierung eher nicht zu empfehlen. Sie macht Änderungen der Menükarte enorm umständlich und sie bürdet der Befehlsklasse eine Rolle auf, für die sie eigentlich nicht gedacht ist. Besser wäre es, die Instanziierung der einzelnen Gerichte in eine eigens dafür geschaffene Klasse auszulagern. 
            </p>

            <h4>Die Lösung</h4>
            <p>
                Das Factory Method-Pattern empfiehlt uns genau das. Wir erstellen eine neue Klasse <code>GerichteFabrik</code>, die eine Methode zur Erzeugung von Gerichten bereitstellt: <code>erzeugeGericht()</code>. Wie genau diese Methode implementiert wird, interessiert uns dabei erstmal nicht. Dies kann wie im vorigen Beispiel anhand einer Menge von if- bzw. case-Abfragen geschehen, mithilfe geeigneter Datenstrukturen oder auf Grundlage einer inneren bzw. globalen Speisekarten-Klasse. Entscheidend ist, dass wir unsere Klassenstruktur allein durch die Auslagerung schon erheblich verbessert haben. Zudem kann die Gerichtefabrik nun zur Laufzeit ausgetauscht werden.
            </p>

            <b>Neuer Code</b>
            <pre><div class="code"><code>
class GerichteBestellung implements Befehl{

    Gericht gericht;
    GerichteFabrik fabrik;

    public GerichteBestellung(int gerichtID) {
        fabrik = new StandardGerichteFabrik();
        gericht = fabrik.erzeugeGericht(gerichtID);
    }

    void ausfuehren() {
        gericht.zubereiten();
        gericht.servieren();
    }
    
    void setFabrik(GerichteFabrik fabrik) {
        this.fabrik = fabrik;
    }
    
}
            </code></div></pre>


            <form id="factoryForm">
                <h3>Zwischenprüfung</h3>
                <fieldset>
                    Was ist die wesentliche Aufgabe der Fabrikmethode?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="factoryA">
                                Erstellen von Objekt-Kopien
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="factoryA">
                                Instanziieren von Objekten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="factoryA">
                                Einer Variable Initialwerte zuweisen
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="factoryA">
                                Überschreiben eines Konstruktors
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welche Aussagen treffen auf das Factory Method-Muster zu?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="factoryB1">
                                Es fördert die Kapselung
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="factoryB2">
                                Die Objekterzeugung wird ausgelagert
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="factoryB3">
                                Durch die zusätzliche Factory-Klasse erhöht sich die Gesamtanzahl an Klassen in einem Projekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="factoryB4">
                                Eine Factory-Klasse kann keine weiteren Unterklassen haben
                            </label>
                        </li>
                    </ul> 
                </fieldset> 
                <br/>
                <fieldset>
                    Ergänze das untenstehende Gerüst für unsere GerichteFabrik.
                </fieldset>
                <pre><div class="code"><code>
class GerichteFabrik {

    public GerichteFabrik() {}
    
    <input type="text" value="Gericht" style="width: 7ch;" name="factoryC1"> <input type="text" value="erzeugeGericht" style="width: 14ch;color: darkblue;font-weight: bold;" name="factoryC2">(int gerichtID) {
        ...
    }

}
                </code></div></pre>
                <button type="button" onclick="checkFactory('factory')" id="factoryButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="factoryResult"></center>
            </form>
        </div>
        
        <!-- Das Decorator-Pattern -->
        <div id="decorator">
            <h2>Das Decorator-Pattern <a class="testjump" href="#decoratorForm">...direkt zum Test...</a></h2>
            <ul>
                <li>Optionale Garnitur hinzufügen</li>
            </ul>

            <pre><div class="code"><code>
class PizzaMargheritaMitKnoblauch extends PizzaMargherita {}

class PizzaMargheritaMitOregano extends PizzaMargherita {}

class PizzaMargheritaMitScharferSauce extends PizzaMargherita {}

class PizzaMargheritaMitOreganoUndKnoblauch extends PizzaMargherita {}

class PizzaMargheritaMitKnoblauchUndScharferSauce extends PizzaMargherita {}

class PizzaMargheritaMitOreganoUndScharferSauce extends PizzaMargherita {}

class PizzaMargheritaMitKnoblauchUndOreganoUndScharferSauce extends PizzaMargherita {}

            </code></div></pre>

            <b>Neuer Code</b>

            <pre><div class="code"><code>
abstract class Garnitur implements Gericht {}
            </code></div></pre>
            
            <pre><div class="code"><code>
enum GarniturTyp {

  KNOBLAUCH,
  SCHARF,
  OREGANO

}
            </code></div></pre>
            
            <pre><div class="code"><code>
class Knoblauch extends Garnitur {

    Gericht gericht;
    public Knoblauch(Gericht gericht) {
        this.gericht = gericht;
    }

    zubereiten() {
        gericht.zubereiten();
        ...
    }
  
}
            </code></div></pre>
            
            <pre><div class="code"><code>
class GerichteFabrik {

    // erzeugt ein einfaches Gericht aus der Karte
    Gericht erzeugeGericht(int gerichtID){...}

    // dem Gericht eine Garnitur hinzufügen
    Gericht dekoriereGarnitur(Gericht gericht, GarniturTyp garniturTyp){

        switch (garniturTyp){

            case KNOBLAUCH:
                return new Knoblauch(gericht);

            case OREGANO:
                return new Oregano(gericht);

            case SCHARF:
                return new ScharfeSauce(gericht);

            default:
                return gericht;

        }

    }

}
            </code></div></pre>

            <form id="decoratorForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Worin besteht die wesentliche Aufgabe eines Decorators?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="decoratorA1" checked=true value="">
                                Erweitern eines Objektes ohne Erzeugung weiterer Unterklassen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="decoratorA2" value="">
                                Bereitstellen überflüssiger Funktionalitäten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="decoratorA3"  value="">
                                Sammeln von Funktionen ohne Rückgabewert
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="decoratorA4" value="">
                                Verbesserung der Fabrikmethode
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkDecorator('decorator')" id="decoratorButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="decoratorResult"></center>
            </form>
        </div>
        
        <!-- Das Strategy-Pattern -->
        <div id="strategy">
            <h2>Das Strategy-Pattern <a class="testjump" href="#strategyForm">...direkt zum Test...</a></h2>
            <ul>
                <li>Sich wiederholende Zubereitungsarten mehrfach nutzen</li>
                <li>Saisonal austauschbare oder verbesserte Rezepte (Algorithmen) einfach umsetzen</li>
            </ul>

            <pre><div class="code"><code>
interface Gericht {

    void zubereiten();
    void servieren();
    List&lt;String&gt; getZutaten();
    ...
  
}

            </code></div></pre>

            <pre><div class="code"><code>
interface Zubereitungsart {

    void zubereiten();

}
            </code></div></pre>
            
            <pre><div class="code"><code>
abstract class Pizza implements Gericht {

    Zubereitungsart zubereitungsart;

    void zubereiten() {

        zubereitungsart.zubereiten();

    }

}
            </code></div></pre>
            
            <pre><div class="code"><code>
class ItalienischeZubereitungsart implements Zubereitungsart {

    void zubereiten() {
        // Pizza auf italienische Art zubereiten
        ...
    }

}
            </code></div></pre>
            
            <pre><div class="code"><code>
class PizzaMargherita extends Pizza {

    public PizzaMargherita() {

        this.zubereitungsart = new ItalienischeZubereitungsart();

    }

}
            </code></div></pre>
            
            <form id="strategyForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Was ist der wesentliche Zweck des Strategy-Ansatzes?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="strategyA1" value="">
                                Einen konkreten Algorithmus möglichst effizient gestalten
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="strategyA2" value="">
                                Die Anzahl der Klassenvariablen optimieren
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="strategyA3"  value="">
                                Den vorrangigen Zweck eines Projektes stets im Auge behalten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="strategyA4" checked=true value="">
                                Algorithmen bzw. Methoden einer Klasse leicht austauschbar halten
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkStrategy('strategy')" id="strategyButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="strategyResult"></center>
            </form>
        </div>
        
        <!-- Das Observer-Pattern -->
        <div id="observer">
            <h2>Das Observer-Pattern <a class="testjump" href="#observerForm">...direkt zum Test...</a></h2>
            <ul>
                <li>Bestellstatus aktualisieren</li>
                <li>java.util.Observable/Observer nutzen</li>
            </ul>

            <pre><div class="code"><code>
class Bestellung extends Observable implements Befehl {

    String status;

    void bestellstatusÄndern(String status) {
        this.status = status;
        setChanged();
        notifyObservers();
    }

    String getStatus() {
        return status;
    }

    ...
}
            </code></div></pre>

            <pre><div class="code"><code>
class Kunde implements Observer {

    String bestellstatus;

    void update(Observable observable, Object arg) {
        if (observable instanceof Bestellung) {
            Bestellung bestellung = (Bestellung) observable;
            bestellstatus = bestellung.getStatus();
        }
    }

}
            </code></div></pre>

            <form id="observerForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Wozu dient das Observer-Muster?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerA1" value="">
                                Vermeidung von zeitgleichen Objektzugriffen bei nebenläufigen Anwendungen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerA2" value="">
                                Effizienteres Pair-Programming
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerA3"  value="">
                                Kontrolle der Nutzung von Variablentypen
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerA4" checked=true value="">
                                Objekte über Änderungen in einem anderen Objekt auf dem Laufenden halten
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welche Aussage stimmt nicht?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerB1" value="">
                                Ein Observable kann mehrere Observer benachrichtigen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerB2" value="">
                                Ein Observer-Objekt kann mehrere Obervables abonieren
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerB3" checked=true value="">
                                <code>java.util.Observable </code> ist ein Interface
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerB4" value="">
                                <code>java.util.Observer </code> ist ein Interface
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkObserver('observer')" id="observerButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="observerResult"></center>
            </form>
        
        </div>
        
        <!-- Der Model-View-Controller -->
        <div id="mvc">
            <h2>Der Model-View-Controller <a class="testjump" href="#mvcForm">...direkt zum Test...</a></h2>
        </div>
        
        <div id="literature">
            <h2>Weiterführende Literatur</h2>
            <ul>
                <li>Freeman, Eric und Elisabeth Robson (2015). <em>Entwurfsmuster von Kopf bis Fuß</em></li>
                <li> [GoF] Gamma, Erich u. a. (2015). <em>Design Patterns. Entwurfsmuster als Elemente wiederverwendbarer
                    objektorientierter Software</em></li>
            </ul>
        </div>
    </body>
    
    <!-- Lösungen anzeigen -->
    <script>solveAll();</script>
</html>
