<!DOCTYPE html>
<html lang="de">

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>BendisPasta | Lernplattform für Design Patterns</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="main.css">
        <link rel="stylesheet" href="javascript/styles/school-book.css">
        <link rel="icon" type="image/jpg" href="pictures/pasta_small.png"/>
    </head>

    <body id="main">

        <!-- syntax highlighting -->
        <script src="javascript/highlight.pack.js"></script>
        
        <!-- website appearance -->
        <script src="script.js"></script>
        
        <!-- multiple choice test evaluation -->
        <script src="check-test.js"></script>
        
        <!-- pop-up notification -->
        <div id="alert">
            <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span> 
            Gratulation! Du kannst jetzt dein Zertifikat herunterladen
        </div>

        <!-- sidebar menu -->
        <div class="sideMenu" id="patternMenu">
            <img src="pictures/pasta_medium.png" alt="Logo">
            <a id="titleMenu" style="font-weight:bold;box-shadow: none;font-style:normal;">Pattern-Menü</a>
            <a id="adapterMenu" style="text-indent:15px;font-size:14px;"href="#adapter"onclick="conditionCloseMenu()">Adapter</a>
            <a id="commandMenu" style="text-indent:15px;font-size:14px;" href="#command"onclick="conditionCloseMenu()">Command</a>
            <a id="factoryMenu" style="text-indent:15px;font-size:14px;"href="#factory"onclick="conditionCloseMenu()">Factory</a>
            <a id="decoratorMenu" style="text-indent:15px;font-size:14px;"href="#decorator"onclick="conditionCloseMenu()">Decorator</a>
            <a id="strategyMenu" style="text-indent:15px;font-size:14px;"href="#strategy"onclick="conditionCloseMenu()">Strategy</a>
            <a id="observerMenu" style="text-indent:15px;font-size:14px;"href="#observer"onclick="conditionCloseMenu()">Observer</a>
            <a id="mvcMenu" style="text-indent:15px;font-size:14px;"href="#mvc"onclick="conditionCloseMenu()">MVC</a>
            <br/>
            <button type="button" style="width: auto;" disabled=true onclick="getCertificate()" id="certificate">Zertifikat erstellen</button>
            <br/>
            <br/>
            <br/>
        </div>

        <!-- sidebar menu icon -->
        <div class="menuIcon">
            <a id="toggle" onclick="openCloseMenu()"><span></span></a>
        </div>

        <!-- title + welcoming text -->
        <div>
            <hr class="italian" />
            <h1>Ristorante BendisPasta</h1>
            <hr class="italian" />
            <h2>Willkommen in der Pizzeria BendisPasta!</h2>

            <p>
                Diese Website dient einem schmackhaften Einstieg in <em>Design Patterns</em> (zu Deutsch: Entwurfsmuster). Hierbei handelt es sich um allgemeine Entwurfsprinzipien, nach denen objektorientierter Softwarecode aufgebaut werden kann. Bei bestimmten wiederkehrenden Anwendungsfällen helfen diese dabei, dass der Code möglichst flexibel an veränderte Anforderungen angepasst oder um erweiterte Funktionalität ergänzt werden kann. Die Kenntnis grundlegender <em>Design Patterns</em> ist für die moderne OO-Entwicklung von elementarer Bedeutung.
            </p>

            <p>
                Im Folgenden wirst du einige der wichtigsten <em>Design Patterns</em> kennen und einzusetzen lernen. Wir werfen dazu einen Blick in die Arbeitswelt der traditionsreichen virtuellen Pizzeria <em>BendisPasta</em>. Ihr Geschäftführer Jens hat dort erst kürzlich angeordnet, die vorherrschenden Arbeitsabläufe nach dem Vorbild der agilen Softwareentwicklung zu modernisieren.
            </p>

        </div>
        
        <!-- Das Adapter-Pattern -->
        <div id="adapter">
            <h2>Das Adapter-Pattern <a class="testjump" href="#adapterForm">...direkt zum Test...</a></h2>
            
            <p>
                Im Restaurant <em>BendisPasta</em> werden in erster Linie zwei Arten von Objekten serviert: Gerichte und Getränke.      
            </p>
            
            <div style="display:flex; flex-wrap: wrap;">
                <div style="margin-left: auto;margin-right: auto;">
                <h4>Gerichte-API</h4>
                <pre><div class="code"><code>
interface Gericht {

    void zubereiten();
    void servieren();
    ...
  
}
                </code></div></pre>
                </div>
                <div style="margin-left: auto;margin-right: auto;">
                <h4>Getränke-API</h4>
                <pre><div class="code"><code>
interface Getraenk {

    void einschaenken();
    void servieren();
    ...
  
}
                </code></div></pre>
                </div>
            </div>
            
            <p>
                Bislang wurde die Methode <code>zubereiten()</code> ausschließlich von einer Instanz der Klasse <code>Koch</code> aufgerufen, das Einschänken der Getränke wurde hingegen von einem <code>Barkeeper</code>-Objekt übernommen. Im Zuge der betrieblichen Rationalisierungsmaßnahmen wird von den Mitarbeitern nun mehr Flexibilität verlangt. Um an besucherarmen Tagen effizienter zu arbeiten, sollen alle Mitarbeiter, die bislang nur mit Gerichten zu tun hatten, auch mit Getränken umgehen können.
            </p>
            
            <h4>Was ist zu tun?</h4>
            <p>
                Im Kern machen die beiden Methoden <code>zubereiten()</code> und <code>einschaenken()</code> dasselbe: Sie bereiten eine Bestellung so vor, dass sie vom Kellner serviert werden kann. Wann immer ein Koch auf einem Gerichte-Objekt <code>zubereiten()</code> aufrufen würde, müsste er also anstelle dessen <code>einschaenken()</code> aufrufen, sofern er es mit einem Getränk zu tun hat. Eine Möglichkeit das zu realisieren besteht in einem Refactoring. Wir könnten z. B. alle Klassen so anpassen, dass <code>Gericht</code> und <code>Getraenk</code> sowie <code>Koch</code>, <code>Barkeeper</code> und alle anderen Mitarbeiter nur noch mit einer einheitlichen Methode (z. B. <code>vorbereiten()</code>) arbeiten. Der Refactoring Ansatz ist jedoch mit hohem Aufwand verbunden, falls die bisherigen Methodennamen und Strukturen schon vielfach genutzt wurden und verstreut im Einsatz sind.
            </p>
            
            <h4>Die Lösung</h4>
            <p>
                Eine schnelle und einfach Lösung des Problems besteht darin, das Adapter-Pattern zu nutzen. Unten siehst du eine Getränke-Adapter-Klasse, die es dem Koch ermöglicht, ein Getränk genau so zu behandeln, wie er es von seinen Gerichten gewohnt ist:
            </p>
            
            
            <pre><div class="code"><code>
class GetraenkeAdapter implements Gericht {

    Getraenk getraenk;

    public GetraenkeAdapter(Getraenk getraenk) {
        this.getraenk = getraenk;
    }

    void zubereiten() {
        getränk.einschaenken();
    }

    void servieren() {
        getränk.servieren();
    }
    ...

}
            </code></div></pre>
        
        
            <p>
                Wann immer wir unserem Koch also ein Getränk übergeben möchten, stecken wir es vorher in einen Getränkeadapter. Wenn wir beispielsweise möchten, dass sich unser Koch um ein Wasser kümmert, so schreiben wir ihm anstelle von <code>new Wasser</code> folgendes auf Aufgabenliste: <code>new GetraenkeAdapter(new Wasser())</code>. Wir erzeugen also ein Objekt der Klasse <code>GetraenkeAdapter</code>, welchem wir im Konstruktor ein Getränk übergeben. Der Getränke-Adapter kümmert sich darum, die Funktionen der Getränke-Klasse in ihre Entsprechungen aus der Gerichte-Klasse zu übersetzen. Da <code>GetraenkeAdapter</code> eine Unterklasse von <code>Gericht</code> ist, sind keine weiteren Änderungen in der <code>Koch</code>-Klasse erforderlich.
            </p>
            
            <h4>Ein Praxisbeispiel</h4>
            <p>
                Wenn du schon eine Weile mit Java gearbeitet hast, wird dir das Interface <code>java.util.Iterator</code> vielleicht ein Begriff sein. Die Schnittstelle bietet vier Funktionen <code>hasNext()</code>, <code>next()</code> sowie <code>remove()</code> und löst damit ihren Vorgänger <code>java.util.Enumeration</code> ab. Die beiden Methoden der Enumeration-Schnittstelle sind <code>hasMoreElements()</code> und <code>nextElement()</code>. Es kann durchaus vorkommen, dass wir in einem alten Java-Projekt auf Enumerations stoßen, obwohl wir inzwischen Iterators verwenden sollten. In einem solchen Fall würde es sich anbieten, mit einem Enumeration-Adapter zu arbeiten.
            </p>
            
            <p class="note">Übrigens: Auch der Iterator ist ein sogenanntes Design Pattern. Zweck des Iterator-Patterns ist es, den Zugriff auf Objekte einer Collection zu ermöglichen, ohne die zugrunde liegende Implementierung zu kennen.</p>
        
            <form id="adapterForm">
                <h3>Zwischenprüfung</h3>
                <fieldset>
                    Was ist die Aufgabe des Adapter-Patterns?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="adapterA1" value="">
                                Transformation von angloamerikanischen Maßeinheiten in das metrische System und umgekehrt
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="adapterA2" value="">
                                Refactoring
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="adapterA3" value="">
                                Es reduziert eine Schnittstelle auf die Elemente, die ein bestimmter Client benötigt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="adapterA4" checked=true value="">
                                Übersetzung der Schnittstelle einer bestimmten Klasse in die Schnittstelle einer ähnlich gearteten anderen Klasse
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welches Objekt wird der Adapter-Klasse im Konstruktor übergeben?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="adapterB1" checked=true value="">
                                Das Objekt, dessen Schnittstelle für den Client übersetzt werden muss
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="adapterB2" value="">
                                Das Objekt, dessen Schnittstelle der Client erwartet
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="adapterB3" value="">
                                Das <code>null</code>-Objekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="adapterB4" value="">
                                Das Client-Objekt
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Ergänze den nachfolgenden Code-Ausschnitt. Zur Erinnerung: Das Interface <code>Iterator</code> besitzt die drei Methoden <code>hasNext()</code>, <code>next()</code> sowie <code>remove()</code>. Das Interface <code>Enumeration</code> hat lediglich die zwei Funktionen <code>hasMoreElements()</code> und <code>nextElement()</code>.
                    </fieldset>
                    <pre><div class="code"><code>
class EnumerationAdapter implements Iterator&lt;E&gt; {

    Enumeration&lt;?&gt; enumeration;

    public EnumerationAdapter(Enumeration&lt;?&gt; enumeration) {
        this.enumeration = enumeration;
    }

    public boolean <input type="text" value="hasNext()" style="width: 9ch;" name="adapterC1"> { // Bitte vervollständigen
        return <input type="text" value="enumeration.hasMoreElements()" style="width: 29ch;" name="adapterC2">; // Bitte vervollständigen
    }

    public E next() {
        return <input type="text" value="enumeration.nextElement()" style="width: 25ch;" name="adapterC3">; // Bitte vervollständigen
    }
    
    public void <input type="text" value="remove()" style="width: 8ch;" name="adapterC4"> { // Bitte vervollständigen
        throw new UnsupportedOperationException();
    }
}
                    </code></div></pre>
                <button type="button" onclick="checkAdapter('adapter')">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<a id="adapterResult"></a>
            </form>
        </div>

        <!-- Das Command-Pattern -->
        <div id="command">
            <h2>Das Command-Pattern <a class="testjump" href="#commandForm">...direkt zum Test...</a></h2>
            <ul>
                <li>Vermittlung von Bestellsystem/Kellner zur Küche/Theke</li>
                <li>Warteschlange in der Küche</li>
            </ul>

            <pre><div class="code"><code>
interface Befehl {
    void ausführen();
}
            </code></div></pre>

            <pre><div class="code"><code>
class Bestellung implements Befehl () {

    List&lt;Gericht&gt; gerichte;
    Küche küche;

    public Bestellung (Küche küche) {
        this.küche = küche;
    }

    void ausführen() {

        for (Gericht g : gerichte) {
            küche.zubereiten(g);
        }

    }

} 
            </code></div></pre>

            <pre><div class="code"><code>
class Abrechnung implements Befehl () {

    Kasse kasse;

    void ausführen() {...}

    }
            </code></div></pre>
    
            <form id="commandForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Was macht das Command-Pattern?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="commandA1" value="">
                                Es kontrolliert eine größere Anzahl verwandter Klassen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="commandA2" value="">
                                Es überwacht die main-Methode
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="commandA3" checked=true value="">
                                Es kapselt einen Auftrag in ein Objekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="commandA4" value="">
                                Es sortiert eine Menge von Befehlen
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Wie heißt üblicherweise die Methode, die von einer konkreten Command-Klasse implementiert werden muss?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="commandB1" value="">
                                <code>command()</code>
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="commandB2" value="">
                                <code>transfer()</code>
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="commandB3" value="">
                                <code>deploy()</code>
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="commandB4" checked=true value="">
                                <code>execute()</code>
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkCommand('command')">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<a id="commandResult"></a>
            </form>
        </div>
        
        <!-- Das Factory-Pattern -->
        <div id="factory">
            <h2>Das Factory-Pattern <a class="testjump" href="#factoryForm">...direkt zum Test...</a></h2>
            <ul>
                <li>Factory zur Herstellung unterschiedlicher Pizzen/Gerichte</li>
            </ul>

            <b>Alter Code</b>

            <pre><div class="code"><code>
class Bestellung implements Befehl {

    List&lt;Gericht&gt; gerichte;

    ...

    void gerichtHinzufügen(int gerichtID) {

        Gericht gericht;

        if(gerichtID == 1) {
            gericht = new InsalataMista();
        } else if (gerichtID == 2) {
            gericht = new InsalataCapricciosa();
        }

        ...

        else if (gerichtID == 35) {
            gericht = new PizzaMargherita();
        } else if (gerichtID == 36) {
            gericht = new PizzaCipolla();
        } else if (gerichtID == 37) {
            gericht = new PizzaCalzone();
        }

        ...

        else if (gerichtID == 68) {
            gericht = new PenneAllArrabiata();
        }

        ...

        gerichte.add(gericht);

    }

    void ausführen() {
        for (Gericht g : gerichte) {
            g.zubereiten();
            g.servieren();
        }

    }
            </code></div></pre>

            <ul>
                <li>if-else/switch/syboltabelle/array, hauptsache auslagern</li>
            </ul>

            <b>Neuer Code</b>

            <pre><div class="code"><code>
class Bestellung implements Befehl{

    List&lt;Gericht&gt; gerichte;
    GerichteFabrik factory;

    ...

    void gerichtHinzufügen(int gerichtID) {

        Gericht gericht = factory.erzeugeGericht(gerichtID);
        gerichte.add(gericht);

    }

    void ausführen() {
        for (Gericht g : gerichte) {
            g.zubereiten();
            g.servieren();
        }

    }
            </code></div></pre>

            <ul>
                <li>
                    Vorteile
                </li>
                <ul>
                    <li>Weniger Zuständigkeiten in der Betellung-Klasse</li>
                    <li>GerichteFabrik kann ggf. zur Laufzeit ausgetauscht werden</li>
                    <li>...</li>
                </ul>
            </ul>

            <form id="factoryForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Was ist die wesentliche Aufgabe der Fabrikmethode?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="factoryA1" value="">
                                Erstellen von Objekt-Kopien
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="factoryA2" checked=true value="">
                                Instanziieren von Objekten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="factoryA3"  value="">
                                Einer Variable Initialwerte zuweisen
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="factoryA4" value="">
                                Überschreiben eines Konstruktors
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welche Aussagen treffen auf das Factory Method-Muster zu?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="factoryB1" value="">
                                Eine Klasse, die dieses Pattern einsetzt, muss eine höhere Anzahl unterschiedlicher Objekte behandeln
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="factoryB2" checked=true value="">
                                Die Objektinstanziierung wird ausgelagert
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="factoryB3" checked=true value="">
                                Durch die zusätzliche Factory-Klasse erhöht sich die Gesamtanzahl an Klassen in einem Projekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="factoryB4" value="">
                                Eine Factory-Klasse kann keine weiteren Unterklassen haben
                            </label>
                        </li>
                    </ul> 
                </fieldset> 
                <br/>
                <button type="button" onclick="checkFactory('factory')">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<a id="factoryResult"></a>
            </form>
        </div>
        
        <!-- Das Decorator-Pattern -->
        <div id="decorator">
            <h2>Das Decorator-Pattern <a class="testjump" href="#decoratorForm">...direkt zum Test...</a></h2>
            <ul>
                <li>Optionale Garnitur hinzufügen</li>
            </ul>

            <pre><div class="code"><code>
class PizzaMargheritaMitKnoblauch extends PizzaMargherita {}

class PizzaMargheritaMitOregano extends PizzaMargherita {}

class PizzaMargheritaMitScharferSauce extends PizzaMargherita {}

class PizzaMargheritaMitOreganoUndKnoblauch extends PizzaMargherita {}

class PizzaMargheritaMitKnoblauchUndScharferSauce extends PizzaMargherita {}

class PizzaMargheritaMitOreganoUndScharferSauce extends PizzaMargherita {}

class PizzaMargheritaMitKnoblauchUndOreganoUndScharferSauce extends PizzaMargherita {}

            </code></div></pre>

            <b>Neuer Code</b>

            <pre><div class="code"><code>
abstract class Garnitur implements Gericht {}
            </code></div></pre>
            
            <pre><div class="code"><code>
enum GarniturTyp {

  KNOBLAUCH,
  SCHARF,
  OREGANO

}
            </code></div></pre>
            
            <pre><div class="code"><code>
class Knoblauch extends Garnitur {

    Gericht gericht;
    public Knoblauch(Gericht gericht) {
        this.gericht = gericht;
    }

    zubereiten() {
        gericht.zubereiten();
        ...
    }
  
}
            </code></div></pre>
            
            <pre><div class="code"><code>
class GerichteFabrik {

    // erzeugt ein einfaches Gericht aus der Karte
    Gericht erzeugeGericht(int gerichtID){...}

    // dem Gericht eine Garnitur hinzufügen
    Gericht dekoriereGarnitur(Gericht gericht, GarniturTyp garniturTyp){

        switch (garniturTyp){

            case KNOBLAUCH:
                return new Knoblauch(gericht);

            case OREGANO:
                return new Oregano(gericht);

            case SCHARF:
                return new ScharfeSauce(gericht);

            default:
                return gericht;

        }

    }

}
            </code></div></pre>

            <form id="decoratorForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Worin besteht die wesentliche Aufgabe eines Decorators?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="decoratorA1" checked=true value="">
                                Erweitern eines Objektes ohne Erzeugung weiterer Unterklassen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="decoratorA2" value="">
                                Bereitstellen überflüssiger Funktionalitäten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="decoratorA3"  value="">
                                Sammeln von Funktionen ohne Rückgabewert
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="decoratorA4" value="">
                                Verbesserung der Fabrikmethode
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkDecorator('decorator')">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<a id="decoratorResult"></a>
            </form>
        </div>
        
        <!-- Das Strategy-Pattern -->
        <div id="strategy">
            <h2>Das Strategy-Pattern <a class="testjump" href="#strategyForm">...direkt zum Test...</a></h2>
            <ul>
                <li>Sich wiederholende Zubereitungsarten mehrfach nutzen</li>
                <li>Saisonal austauschbare oder verbesserte Rezepte (Algorithmen) einfach umsetzen</li>
            </ul>

            <pre><div class="code"><code>
interface Gericht {

    void zubereiten();
    void servieren();
    List&lt;String&gt; getZutaten();
    ...
  
}

            </code></div></pre>

            <pre><div class="code"><code>
interface Zubereitungsart {

    void zubereiten();

}
            </code></div></pre>
            
            <pre><div class="code"><code>
abstract class Pizza implements Gericht {

    Zubereitungsart zubereitungsart;

    void zubereiten() {

        zubereitungsart.zubereiten();

    }

}
            </code></div></pre>
            
            <pre><div class="code"><code>
class ItalienischeZubereitungsart implements Zubereitungsart {

    void zubereiten() {
        // Pizza auf italienische Art zubereiten
        ...
    }

}
            </code></div></pre>
            
            <pre><div class="code"><code>
class PizzaMargherita extends Pizza {

    public PizzaMargherita() {

        this.zubereitungsart = new ItalienischeZubereitungsart();

    }

}
            </code></div></pre>
            
            <form id="strategyForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Was ist der wesentliche Zweck des Strategy-Ansatzes?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="strategyA1" value="">
                                Einen konkreten Algorithmus möglichst effizient gestalten
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="strategyA2" value="">
                                Die Anzahl der Klassenvariablen optimieren
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="strategyA3"  value="">
                                Den vorrangigen Zweck eines Projektes stets im Auge behalten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="strategyA4" checked=true value="">
                                Algorithmen bzw. Methoden einer Klasse leicht austauschbar halten
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkStrategy('strategy')">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<a id="strategyResult"></a>
            </form>
        </div>
        
        <!-- Das Observer-Pattern -->
        <div id="observer">
            <h2>Das Observer-Pattern <a class="testjump" href="#observerForm">...direkt zum Test...</a></h2>
            <ul>
                <li>Bestellstatus aktualisieren</li>
                <li>java.util.Observable/Observer nutzen</li>
            </ul>

            <pre><div class="code"><code>
class Bestellung extends Observable implements Befehl {

    String status;

    void bestellstatusÄndern(String status) {
        this.status = status;
        setChanged();
        notifyObservers();
    }

    String getStatus() {
        return status;
    }

    ...
}
            </code></div></pre>

            <pre><div class="code"><code>
class Kunde implements Observer {

    String bestellstatus;

    void update(Observable observable, Object arg) {
        if (observable instanceof Bestellung) {
            Bestellung bestellung = (Bestellung) observable;
            bestellstatus = bestellung.getStatus();
        }
    }

}
            </code></div></pre>

            <form id="observerForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Wozu dient das Observer-Muster?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerA1" value="">
                                Vermeidung von zeitgleichen Objektzugriffen bei nebenläufigen Anwendungen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerA2" value="">
                                Effizienteres Pair-Programming
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerA3"  value="">
                                Kontrolle der Nutzung von Variablentypen
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerA4" checked=true value="">
                                Objekte über Änderungen in einem anderen Objekt auf dem Laufenden halten
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welche Aussage stimmt nicht?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerB1" value="">
                                Ein Observable kann mehrere Observer benachrichtigen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerB2" value="">
                                Ein Observer-Objekt kann mehrere Obervables abonieren
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerB3" checked=true value="">
                                <code>java.util.Observable </code> ist ein Interface
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerB4" value="">
                                <code>java.util.Observer </code> ist ein Interface
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkObserver('observer')">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<a id="observerResult"></a>
            </form>
        
        </div>
        
        <!-- Der Model-View-Controller -->
        <div id="mvc">
            <h2>Der Model-View-Controller <a class="testjump" href="#mvcForm">...direkt zum Test...</a></h2>
        </div>
        
        <div id="literature">
            <h2>Weiterführende Literatur</h2>
            <ul>
                <li>Freeman, Eric und Elisabeth Robson (2015). <em>Entwurfsmuster von Kopf bis Fuß</em></li>
                <li>Gamma, Erich u. a. (2015). <em>Design Patterns. Entwurfsmuster als Elemente wiederverwendbarer
                    objektorientierter Software</em></li>
            </ul>
        </div>
    </body>
</html>
