<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Bendispasta | Lernplattform für Design Patterns</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="main.css">
        <link rel="stylesheet" href="javascript/styles/school-book.css">
        <link rel="icon" type="image/jpg" href="pictures/pasta_small.png"/>
    </head>

    <body>

        <!-- include JavaScript -->
        <script src="javascript/highlight.pack.js"></script>
        <script src="script.js"></script>

        <!-- sidebar menu -->
        <div class="sideMenu" id="patternMenu">
            <a style="font-weight:bold;color:darkred;font-style:normal;"onclick="openCloseMenu()">Pattern-Menü</a>
            <a id="commandMenu" style="text-indent:15px;font-size:14px;" href="#command"onclick="openCloseMenu()">Command</a>
            <a id="factoryMenu" style="text-indent:15px;font-size:14px;"href="#factory"onclick="openCloseMenu()">Factory</a>
            <a id="decoratorMenu" style="text-indent:15px;font-size:14px;"href="#decorator"onclick="openCloseMenu()">Decorator</a>
            <a id="strategyMenu" style="text-indent:15px;font-size:14px;"href="#strategy"onclick="openCloseMenu()">Strategy</a>
            <a id="observerMenu" style="text-indent:15px;font-size:14px;"href="#observer"onclick="openCloseMenu()">Observer</a>
            <a id="adapterMenu" style="text-indent:15px;font-size:14px;"href="#adapter"onclick="openCloseMenu()">Adapter</a>
            <a id="mvcMenu" style="text-indent:15px;font-size:14px;"href="#mvc"onclick="openCloseMenu()">MVC</a>
        </div>

        <!-- sidebar menu icon -->
        <div class="menuIcon">
            <a id="toggle" href="javascript:void(0)" onclick="openCloseMenu()"><span></span></a>
        </div>

        <!-- title + welcoming text -->
        <div>
            <div class="header">
                <h1>Il Ristorante Bendispasta</h1>
                <img src="pictures/pasta_medium.png" alt="Logo">
            </div>
            <hr class="italian" />
            <h2>Willkommen in der Pizzeria Bendispasta!</h2>

            <p>
                Diese Website dient dem appetitlichen Einstieg in <em>Design Patterns</em> (zu deutsch: Entwurfsmuster). Hierbei handelt es sich um allgemeine Entwurfsprinzipien, nach denen objektorientierter Softwarecode aufgebaut werden kann. Bei bestimmten wiederkehrenden Anwendungsfällen helfen diese dabei, dass der Code möglichst flexibel an veränderte Anforderungen angepasst oder um erweiterte Funktionalität ergänzt werden kann. Die Kenntnis grundlegender <em>Design Patterns</em> ist für die moderne OO-Entwicklung von elementarer Bedeutung.
            </p>

            <p>
                Im Folgenden wirst du einige der wichtigsten <em>Design Patterns</em> kennen und einzusetzen lernen. Wir werfen dazu einen Blick in die Arbeitswelt der traditionsreichen virtuellen Pizzeria <em>Bendispasta</em>. Ihr Geschäftführer Jens hat dort erst kürzlich angeordnet, die vorherrschenden Arbeitsabläufe nach dem Vorbild der agilen Softwareentwicklung zu modernisieren.
            </p>

        </div>

        <!-- Das Command-Pattern -->
        <div id="command">
            <h3>Das Command-Pattern</h3>
            <a style="cursor:pointer;text-decoration:none;font-size:12px;margin-left: 2em;" href="#commandForm">direkt zur Test-Abfrage...</a>
            <ul>
                <li>Vermittlung von Bestellsystem/Kellner zur Küche/Theke</li>
                <li>Warteschlange in der Küche</li>
            </ul>

            <pre><div class="code"><code>
interface Befehl {
    void ausführen();
}
            </code></div></pre>

            <pre><div class="code"><code>
class Bestellung implements Befehl () {

    List&lt;Gericht&gt; gerichte;
    Küche küche;

    public Bestellung (Küche küche) {
        this.küche = küche;
    }

    void ausführen() {

        for (Gericht g : gerichte) {
            küche.zubereiten(g);
        }

    }

} 
            </code></div></pre>

            <pre><div class="code"><code>
class Abrechnung implements Befehl () {

    Kasse kasse;

    void ausführen() {...}

    }
            </code></div></pre>
    
            <form id="commandForm">
                <h4>Multiple-Choice</h4>
                <fieldset>
                    Was macht das Command-Pattern?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="commandA1" value="">
                                Es kontrolliert eine größere Anzahl verwandter Klassen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="commandA2" value="">
                                Es überwacht die main-Methode
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="commandA3" checked=true value="">
                                Es kapselt einen Auftrag in ein Objekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="commandA4" value="">
                                Es sortiert eine Menge von Befehlen
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Wie heißt üblicherweise die Methode, die von einer konkreten Command-Klasse implementiert werden muss?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="commandB1" value="">
                                <code>command()</code>
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="commandB2" value="">
                                <code>transfer()</code>
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="commandB3" value="">
                                <code>deploy()</code>
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="commandB4" checked=true value="">
                                <code>execute()</code>
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkCommand()">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<a id="commandResult"></a>
            </form>
        </div>
        
        <!-- Das Factory-Pattern -->
        <div id="factory">
            <h3>Das Factory-Pattern</h3>
            <ul>
                <li>Factory zur Herstellung unterschiedlicher Pizzen/Gerichte</li>
            </ul>

            <b>Alter Code</b>

            <pre><div class="code"><code>
class Bestellung implements Befehl {

    List&lt;Gericht&gt; gerichte;

    ...

    void gerichtHinzufügen(int gerichtID) {

        Gericht gericht;

        if(gerichtID == 1) {
            gericht = new InsalataMista();
        } else if (gerichtID == 2) {
            gericht = new InsalataCapricciosa();
        }

        ...

        else if (gerichtID == 35) {
            gericht = new PizzaMargherita();
        } else if (gerichtID == 36) {
            gericht = new PizzaCipolla();
        } else if (gerichtID == 37) {
            gericht = new PizzaCalzone();
        }

        ...

        else if (gerichtID == 68) {
            gericht = new PenneAllArrabiata();
        }

        ...

        gerichte.add(gericht);

    }

    void ausführen() {
        for (Gericht g : gerichte) {
            g.zubereiten();
            g.servieren();
        }

    }
            </code></div></pre>

            <ul>
                <li>if-else/switch/syboltabelle/array, hauptsache auslagern</li>
            </ul>

            <b>Neuer Code</b>

            <pre><div class="code"><code>
class Bestellung implements Befehl{

    List&lt;Gericht&gt; gerichte;
    GerichteFabrik factory;

    ...

    void gerichtHinzufügen(int gerichtID) {

        Gericht gericht = factory.erzeugeGericht(gerichtID);
        gerichte.add(gericht);

    }

    void ausführen() {
        for (Gericht g : gerichte) {
            g.zubereiten();
            g.servieren();
        }

    }
            </code></div></pre>

            <ul>
                <li>
                    Vorteile
                </li>
                <ul>
                    <li>Weniger Zuständigkeiten in der Betellung-Klasse</li>
                    <li>GerichteFabrik kann ggf. zur Laufzeit ausgetauscht werden</li>
                    <li>...</li>
                </ul>
            </ul>

            <h4>Multiple-Choice</h4>

            <form>
                <fieldset>
                    Was ist die wesentliche Aufgabe der Fabrikmethode?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="a1" value="">
                                Erstellen von Objekt-Kopien
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="a2" checked=true value="">
                                Instanziieren von Objekten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a3"  value="">
                                Einer Variable Initialwerte zuweisen
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a4" value="">
                                Überschreiben eines Konstruktors
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welche Aussagen treffen auf das Factory Method-Muster zu?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="a1" value="">
                                Eine Klasse, die dieses Pattern einsetzt, muss eine höhere Anzahl unterschiedlicher Objekte behandeln
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="a2" checked=true value="">
                                Die Objektinstanziierung wird ausgelagert
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a3" checked=true value="">
                                Durch die zusätzliche Factory-Klasse erhöht sich die Gesamtanzahl an Klassen in einem Projekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a4" value="">
                                Eine Factory-Klasse kann keine weiteren Unterklassen haben
                            </label>
                        </li>
                    </ul> 
                </fieldset> 
            </form>
        </div>
        
        <!-- Das Decorator-Pattern -->
        <div id="decorator">
            <h3>Das Decorator-Pattern</h3>
            <ul>
                <li>Optionale Garnitur hinzufügen</li>
            </ul>

            <pre><div class="code"><code>
class PizzaMargheritaMitKnoblauch extends PizzaMargherita {}

class PizzaMargheritaMitOregano extends PizzaMargherita {}

class PizzaMargheritaMitScharferSauce extends PizzaMargherita {}

class PizzaMargheritaMitOreganoUndKnoblauch extends PizzaMargherita {}

class PizzaMargheritaMitKnoblauchUndScharferSauce extends PizzaMargherita {}

class PizzaMargheritaMitOreganoUndScharferSauce extends PizzaMargherita {}

class PizzaMargheritaMitKnoblauchUndOreganoUndScharferSauce extends PizzaMargherita {}

            </code></div></pre>

            <b>Neuer Code</b>

            <pre><div class="code"><code>
abstract class Garnitur implements Gericht {}
            </code></div></pre>
            
            <pre><div class="code"><code>
enum GarniturTyp {

  KNOBLAUCH,
  SCHARF,
  OREGANO

}
            </code></div></pre>
            
            <pre><div class="code"><code>
class Knoblauch extends Garnitur {

    Gericht gericht;
    public Knoblauch(Gericht gericht) {
        this.gericht = gericht;
    }

    zubereiten() {
        gericht.zubereiten();
        ...
    }
  
}
            </code></div></pre>
            
            <pre><div class="code"><code>
class GerichteFabrik {

    // erzeugt ein einfaches Gericht aus der Karte
    Gericht erzeugeGericht(int gerichtID){...}

    // dem Gericht eine Garnitur hinzufügen
    Gericht dekoriereGarnitur(Gericht gericht, GarniturTyp garniturTyp){

        switch (garniturTyp){

            case KNOBLAUCH:
                return new Knoblauch(gericht);

            case OREGANO:
                return new Oregano(gericht);

            case SCHARF:
                return new ScharfeSauce(gericht);

            default:
                return gericht;

        }

    }

}
            </code></div></pre>

            <h4>Multiple-Choice</h4>

            <form>
                <fieldset>
                    Worin besteht die wesentliche Aufgabe eines Decorators?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="a1" checked=true value="">
                                Erweitern eines Objektes ohne Erzeugung weiterer Unterklassen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="a2" value="">
                                Bereitstellen überflüssiger Funktionalitäten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a3"  value="">
                                Sammeln von Funktionen ohne Rückgabewert
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a4" value="">
                                Verbesserung der Fabrikmethode
                            </label>
                        </li>
                    </ul> 
                </fieldset>
            </form>
        </div>
        
        <!-- Das Strategy-Pattern -->
        <div id="strategy">
            <h3>Das Strategy-Pattern</h3>
            <ul>
                <li>Sich wiederholende Zubereitungsarten mehrfach nutzen</li>
                <li>Saisonal austauschbare oder verbesserte Rezepte (Algorithmen) einfach umsetzen</li>
            </ul>

            <pre><div class="code"><code>
interface Gericht {

    void zubereiten();
    void servieren();
    List&lt;String&gt; getZutaten();
    ...
  
}

            </code></div></pre>

            <pre><div class="code"><code>
interface Zubereitungsart {

    void zubereiten();

}
            </code></div></pre>
            
            <pre><div class="code"><code>
abstract class Pizza implements Gericht {

    Zubereitungsart zubereitungsart;

    void zubereiten() {

        zubereitungsart.zubereiten();

    }

}
            </code></div></pre>
            
            <pre><div class="code"><code>
class ItalienischeZubereitungsart implements Zubereitungsart {

    void zubereiten() {
        // Pizza auf italienische Art zubereiten
        ...
    }

}
            </code></div></pre>
            
            <pre><div class="code"><code>
class PizzaMargherita extends Pizza {

    public PizzaMargherita() {

        this.zubereitungsart = new ItalienischeZubereitungsart();

    }

}
            </code></div></pre>

            <h4>Multiple-Choice</h4>

            <form>
                <fieldset>
                    Was ist der wesentliche Zweck des Strategy-Ansatzes?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="a1" value="">
                                Einen konkreten Algorithmus möglichst effizient gestalten
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="a2" value="">
                                Die Anzahl der Klassenvariablen optimieren
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a3"  value="">
                                Den vorrangigen Zweck eines Projektes stets im Auge behalten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a4" checked=true value="">
                                Algorithmen bzw. Methoden einer Klasse leicht austauschbar halten
                            </label>
                        </li>
                    </ul> 
                </fieldset>
            </form>
        </div>
        
        <!-- Das Observer-Pattern -->
        <div id="observer">
            <h3>Das Observer-Pattern</h3>
            <ul>
                <li>Bestellstatus aktualisieren</li>
                <li>java.util.Observable/Observer nutzen</li>
            </ul>

            <pre><div class="code"><code>
class Bestellung extends Observable implements Befehl {

    String status;

    void bestellstatusÄndern(String status) {
        this.status = status;
        setChanged();
        notifyObservers();
    }

    String getStatus() {
        return status;
    }

    ...
}
            </code></div></pre>

            <pre><div class="code"><code>
class Kunde implements Observer {

    String bestellstatus;

    void update(Observable observable, Object arg) {
        if (observable instanceof Bestellung) {
            Bestellung bestellung = (Bestellung) observable;
            bestellstatus = bestellung.getStatus();
        }
    }

}
            </code></div></pre>
            
            <h4>Multiple-Choice</h4>

            <form>
                <fieldset>
                    Wozu dient das Observer-Muster?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="a1" value="">
                                Vermeidung von zeitgleichen Objektzugriffen bei nebenläufigen Anwendungen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="a2" value="">
                                Effizienteres Pair-Programming
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a3"  value="">
                                Kontrolle der Nutzung von Variablentypen
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a4" checked=true value="">
                                Objekte über Änderungen in einem anderen Objekt auf dem Laufenden halten
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welche Aussage stimmt nicht?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="a1" value="">
                                Ein Observable kann mehrere Observer benachrichtigen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="a2" value="">
                                Ein Observer-Objekt kann mehrere Obervables abonieren
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a3" checked=true value="">
                                <code>java.util.Observable </code> ist ein Interface
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="a4" value="">
                                <code>java.util.Observer </code> ist ein Interface
                            </label>
                        </li>
                    </ul> 
                </fieldset>
            </form>
        
        </div>
        
        <!-- Das Adapter-Pattern -->
        <div id="adapter">
            <h3>Das Adapter-Pattern</h3>
            <ul>
                <li>Gleichbehandlung von Getränken und Gerichten</li>
            </ul>

            <pre><div class="code"><code>
interface Gericht {

    void zubereiten();
    void servieren();
    List&lt;String&gt; getZutaten();

    ...
  
}

            </code></div></pre>

            <pre><div class="code"><code>
interface Getränk {

    void zubereiten();
    void einschänken();
    List&lt;String&gt; getZutaten();
    ...
  
}
            </code></div></pre>
            
            <pre><div class="code"><code>
class GetränkeAdapter implements Gericht {

    Getränk getränk;

    public GetränkeAdapter(Getränk getränk) {
        this.getränk = getränk;
    }

    void zubereiten() {
        getränk.zubereiten();
    }

    void servieren() {
        getränk.einschänken();
    }
    ...

}
            </code></div></pre>
        </div>
        
        <!-- Der Model-View-Controller -->
        <div id="mvc">
            <h3>Der Model-View-Controller</h3>
        </div>
    </body>
</html>
