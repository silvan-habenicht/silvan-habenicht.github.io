<!DOCTYPE html>
<html lang="de">

    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>BendisPasta | Lernplattform für Design Patterns</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="main.css">
        <link rel="stylesheet" href="javascript/styles/school-book.css">
        <link rel="icon" type="image/jpg" href="pictures/pasta_small.png"/>
    </head>

    <body id="main">

        <!-- syntax highlighting -->
        <script src="javascript/highlight.pack.js"></script>
        
        <!-- website appearance -->
        <script src="script.js"></script>
        
        <!-- multiple choice test evaluation -->
        <script src="check-test.js"></script>
        
        <audio src="audio/tinder-message.mp3" type="audio/mpeg"></audio>
        
        <!-- pop-up notification -->
        <div id="alert">
            <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span> 
            Gratulation! Du kannst jetzt dein Zertifikat herunterladen
        </div>

        <!-- sidebar menu -->
        <div class="sideMenu" id="patternMenu">
            <img src="pictures/pasta_medium.png" alt="Logo">
            <a id="titleMenu" style="font-weight:bold;box-shadow: none;font-style:normal;">Pattern-Menü</a>
            <a id="adapterMenu" style="text-indent:15px;font-size:14px;"href="#adapter"onclick="conditionCloseMenu()">Adapter</a>
            <a id="commandMenu" style="text-indent:15px;font-size:14px;" href="#command"onclick="conditionCloseMenu()">Command</a>
            <a id="observerMenu" style="text-indent:15px;font-size:14px;"href="#observer"onclick="conditionCloseMenu()">Observer</a>
            <a id="factoryMenu" style="text-indent:15px;font-size:14px;"href="#factory"onclick="conditionCloseMenu()">Factory</a>
            <a id="strategyMenu" style="text-indent:15px;font-size:14px;"href="#strategy"onclick="conditionCloseMenu()">Strategy</a>
            <a id="decoratorMenu" style="text-indent:15px;font-size:14px;"href="#decorator"onclick="conditionCloseMenu()">Decorator</a>
            <a id="mvcMenu" style="text-indent:15px;font-size:14px;"href="#mvc"onclick="conditionCloseMenu()">MVC</a>
            <br/>
            <button type="button" style="width: auto;" disabled=true onclick="getCertificate()" id="certificate">Zertifikat erstellen</button>
            <br/>
            <br/>
            <br/>
        </div>

        <!-- sidebar menu icon -->
        <div class="menuIcon">
            <a id="toggle" onclick="openCloseMenu()"><span></span></a>
        </div>

        <!-- title + welcoming text -->
        <div>
            <hr class="italian" />
            <h1>Ristorante BendisPasta</h1>
            <hr class="italian" />
            <h2>Willkommen in der Pizzeria BendisPasta!</h2>

            <p>
                Diese Website dient einem schmackhaften Einstieg in <em>Design Patterns</em> (zu Deutsch: Entwurfsmuster). Hierbei handelt es sich um allgemeine Entwurfsprinzipien, nach denen objektorientierter Softwarecode aufgebaut werden kann. Bei bestimmten wiederkehrenden Anwendungsfällen helfen diese dabei, dass der Code möglichst flexibel an veränderte Anforderungen angepasst oder um erweiterte Funktionalität ergänzt werden kann. Die Kenntnis grundlegender <em>Design Patterns</em> ist für die moderne OO-Entwicklung von elementarer Bedeutung.
            </p>

            <p>
                Im Folgenden wirst du einige der wichtigsten <em>Design Patterns</em> kennen und einzusetzen lernen. Wir werfen dazu einen Blick in die Arbeitswelt der traditionsreichen virtuellen Pizzeria <em>BendisPasta</em>. Ihr Geschäftsführer Jens hat dort erst kürzlich angeordnet, die vorherrschenden Arbeitsabläufe nach dem Vorbild der agilen Softwareentwicklung zu modernisieren.
            </p>

        </div>
        
        <!-- Das Adapter-Pattern -->
        <div id="adapter">
            <h2>Das Adapter-Pattern <a class="testjump" href="#adapterForm">...direkt zum Test...</a></h2>
            
            <p class="note">
                Zur „Anpassung der Schnittstelle einer Klasse an ein anderes von den Clients erwartetes Interface. Das Design Pattern Adapter (Adapter) ermöglicht die Zusammenarbeit von Klassen, die ansonsten aufgrund der Inkompatibilität ihrer Schnittstellen nicht dazu in der Lage wären.“ [GoF]
            </p>
            
            <p>
                Im Restaurant <em>BendisPasta</em> werden in erster Linie zwei Arten von Objekten serviert: Gerichte und Getränke.      
            </p>
            
            <div style="display:flex; flex-wrap: wrap;">
                <div style="margin-left: auto;margin-right: auto;overflow-x: scroll;">
                <h4>Gerichte-API</h4>
                <pre><div class="code"><code>
interface Gericht {

    void zubereiten();
    void servieren();
  
}
                </code></div></pre>
                </div>
                <div style="margin-left: auto;margin-right: auto;overflow-x: scroll;">
                <h4>Getränke-API</h4>
                <pre><div class="code"><code>
interface Getraenk {

    void einschaenken();
    void servieren();
  
}
                </code></div></pre>
                </div>
            </div>
            
            <p>
                Bislang wurde die Methode <code>zubereiten()</code> ausschließlich von einer Instanz der Klasse <code>Koch</code> aufgerufen, das Einschänken der Getränke wurde hingegen von einem <code>Barkeeper</code>-Objekt übernommen. Im Zuge der betrieblichen Rationalisierungsmaßnahmen wird von den Mitarbeitern nun mehr Flexibilität verlangt. Um an besucherarmen Tagen effizienter zu arbeiten, sollen alle Mitarbeiter, die bislang nur mit Gerichten zu tun hatten, auch mit Getränken umgehen können.
            </p>
            
            <h4>Was ist zu tun?</h4>
            <p>
                Im Kern machen die beiden Methoden <code>zubereiten()</code> und <code>einschaenken()</code> dasselbe: Sie bereiten eine Bestellung so vor, dass sie vom Kellner serviert werden kann. Wann immer ein Koch auf einem Gerichte-Objekt <code>zubereiten()</code> aufrufen würde, müsste er also anstelle dessen <code>einschaenken()</code> aufrufen, sofern er es mit einem Getränk zu tun hat. Eine Möglichkeit das zu realisieren besteht in einem Refactoring. Wir könnten z. B. alle Klassen so anpassen, dass <code>Gericht</code> und <code>Getraenk</code> sowie <code>Koch</code>, <code>Barkeeper</code> und alle anderen Mitarbeiter nur noch mit einer einheitlichen Methode (z. B. <code>vorbereiten()</code>) arbeiten. Der Refactoring Ansatz ist jedoch mit hohem Aufwand verbunden, falls die bisherigen Methodennamen und Strukturen schon vielfach genutzt wurden und verstreut im Einsatz sind.
            </p>
            
            <h4>Die Lösung</h4>
            <p>
                Eine schnelle und einfach Lösung des Problems besteht darin, das Adapter-Pattern zu nutzen. Unten siehst du eine Getränke-Adapter-Klasse, die es dem Koch ermöglicht, ein Getränk genau so zu behandeln, wie er es von seinen Gerichten gewohnt ist:
            </p>
            
            
            <pre><div class="code"><code>
class GetraenkeAdapter implements Gericht {

    Getraenk getraenk;

    public GetraenkeAdapter(Getraenk getraenk) {
        this.getraenk = getraenk;
    }

    void zubereiten() {
        getränk.einschaenken();
    }

    void servieren() {
        getränk.servieren();
    }
    ...

}
            </code></div></pre>
        
        
            <p>
                Wann immer wir unserem Koch also ein Getränk übergeben möchten, stecken wir es vorher in einen Getränkeadapter. Wenn wir beispielsweise möchten, dass sich unser Koch um ein Wasser kümmert, so schreiben wir ihm anstelle von <code>new Wasser</code> folgendes auf Aufgabenliste: <code>new GetraenkeAdapter(new Wasser())</code>. Wir erzeugen also ein Objekt der Klasse <code>GetraenkeAdapter</code>, welchem wir im Konstruktor ein Getränk übergeben. Der Getränke-Adapter kümmert sich darum, die Funktionen der Getränke-Klasse in ihre Entsprechungen aus der Gerichte-Klasse zu übersetzen. Da <code>GetraenkeAdapter</code> eine Unterklasse von <code>Gericht</code> ist, sind keine weiteren Änderungen in der <code>Koch</code>-Klasse erforderlich.
            </p>
            
            <h4>Ein Praxisbeispiel</h4>
            <p>
                Wenn du schon eine Weile mit Java gearbeitet hast, wird dir das Interface <code>java.util.Iterator</code> vielleicht ein Begriff sein. Die Schnittstelle beinhaltet die Funktionen <code>hasNext()</code>, <code>next()</code> sowie <code>remove()</code> und löst damit ihren Vorgänger <code>java.util.Enumeration</code> ab. Die beiden Methoden der Enumeration-Schnittstelle sind <code>hasMoreElements()</code> und <code>nextElement()</code>. Es kann durchaus vorkommen, dass wir in einem alten Java-Projekt auf Enumerations stoßen, obwohl wir inzwischen Iterators verwenden. In einem solchen Fall würde es sich anbieten, mit einem Enumeration-Adapter zu arbeiten.
            </p>
            
            <p class="note">
                Übrigens: Auch der Iterator ist ein sogenanntes Design Pattern. Zweck des Iterator-Patterns ist es, den Zugriff auf Objekte einer Collection zu ermöglichen, ohne die zugrunde liegende Implementierung zu kennen.
            </p>
        
            <form id="adapterForm">
                <h3>Zwischenprüfung</h3>
                <fieldset>
                    Was ist die Aufgabe des Adapter-Patterns?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="adapterA">
                                Transformation von angloamerikanischen Maßeinheiten in das metrische System und umgekehrt
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="adapterA">
                                Refactoring
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="adapterA" >
                                Es reduziert eine Schnittstelle auf die Elemente, die ein bestimmter Client benötigt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="adapterA">
                                Übersetzung der Schnittstelle einer bestimmten Klasse in die Schnittstelle einer ähnlich gearteten anderen Klasse
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welches Objekt wird der Adapter-Klasse im Konstruktor übergeben?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="adapterB">
                                Das Objekt, dessen Schnittstelle für den Client übersetzt werden muss
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="adapterB">
                                Das Objekt, dessen Schnittstelle der Client erwartet
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="adapterB">
                                Das <code>null</code>-Objekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="adapterB">
                                Das Client-Objekt
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Ergänze den nachfolgenden Code-Ausschnitt. Zur Erinnerung: Das Interface <code>Iterator</code> besitzt die drei Methoden <code>hasNext()</code>, <code>next()</code> sowie <code>remove()</code>. Das Interface <code>Enumeration</code> hat lediglich die beiden Funktionen <code>hasMoreElements()</code> und <code>nextElement()</code>.
                </fieldset>
                <pre><div class="code"><code>
class EnumerationAdapter implements Iterator&lt;E&gt; {

    Enumeration&lt;?&gt; enumeration;

    public EnumerationAdapter(Enumeration&lt;?&gt; enumeration) {
        this.enumeration = enumeration;
    }

    public boolean <input type="text" value = "hasNext()" style="width: 9ch;" name="adapterC1"> { // Bitte vervollständigen
        return <input type="text" value="enumeration.hasMoreElements()" style="width: 29ch;" name="adapterC2">; // Bitte vervollständigen
    }

    public E next() {
        return <input type="text" value="enumeration.nextElement()" style="width: 25ch;" name="adapterC3">; // Bitte vervollständigen
    }
    
    public void <input type="text" value="remove()" style="width: 8ch;" name="adapterC4"> { // Bitte vervollständigen
        throw new UnsupportedOperationException();
    }
    
}
                </code></div></pre>
                <button type="button" onclick="checkAdapter()" id="adapterButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="adapterResult"></center>
            </form>
        </div>

        <!-- Das Command-Pattern -->
        <div id="command">
            <h2>Das Command-Pattern <a class="testjump" href="#commandForm">...direkt zum Test...</a></h2>
            
            <p class="note">
                Zur „Kapselung eines Requests als Objekt, um so die Parametrisierung von Clients mit verschiedenen Requests, Warteschlangen- oder Logging-Operationen sowie das Rückgängigmachen von Operationen zu ermöglichen.“ [GoF]
            </p>
            
            <p>
                In letzter Zeit gab es mehrere Beschwerden von Kunden des Ristorante Bendispasta, die etwa versucht haben bei einem Koch ein Getränk zu bestellen. Sie wurden barsch zurückgewiesen mit Aussagen wie „Dafür bin ich nicht zuständig!“ oder „Jetzt nicht!“. Ein Ähnliches verhalten legten auch andere Mitarbeiter an den Tag. Viele Kunden sind verunsichert, an wen Sie sich mit Ihren Bestellwünschen wenden sollen. 
            </p>
            
            <h4>Was ist zu tun?</h4>
            
            <p>
                Unser Geschäftsführer Jens schlägt vor, die ausführenden Mitarbeiter von den Kunden zu entkoppeln. Jegliche Bestellung soll nur noch über einen Vermittler, den Kellner, abgewickelt werden. Dem Kunde kann egal sein auf welchem Wege sein Gericht zubereitet, sein Getränk einschenkt oder ihm eine <a target="_blank" href="https://www.youtube.com/watch?v=XFj45oeA7bE" >saubere Gabel</a> gebracht wird &mdash; Ansprechpartner soll in allen Fällen der Kellner sein.
            </p>
            
            <h4>Die Lösung</h4>
            
            <p>
                An dieser Stelle bedienen wir uns dem Command-Pattern, welches sich in vier Klassen und ein Interface gliedert: Es gibt den Kunden (<em>Client</em>), den Empfänger (<em>Receiver</em>), den Aufrufer (<em>Invoker</em>) und den konkreten Befehl (<em>concrete Command</em>), der ein Interface vom Typ Befehl (<em>Command</em>) implementiert. Dieses Interface, enthält eine einzige Methode <code>ausfuehren()</code> bzw. <code>execute()</code>:
            </p>

            <pre><div class="code"><code>
interface Befehl {
    void ausfuehren();
}

            </code></div></pre>
            
            <p>
                Der Ablauf in einem Command-Pattern sieht in etwa wie folgt aus: Der Kunde erzeugt zunächst ein konkretes Befehls-Objekt und benennt darin den Empfänger (das Objekt, welches den Befehl am Ende ausführen soll/kann). Der Aufrufer nimmt das Befehls-Objekt entgegen, speichert es und ruft bei Gelegenheit dessen ausfuehren()-Methode auf. Diese wiederum ruft den Empfänger auf, der schließlich den eigentlichen Befehl ausführt. Sehen wir uns einmal an, wie so eine konkrete Befehls-Klasse aussehen könnte. Der Empfänger ist in diesem Fall ein Gericht:
            </p>
            
            <pre><div class="code"><code>
class GerichteBestellung implements Befehl {

    Gericht gericht;

    public GerichteBestellung (Gericht gericht) {
        this.gericht = gericht;
    }

    void ausfuehren() {
        gericht.zubereiten();
        gericht.servieren();
    }

} 
            </code></div></pre>
            
            <p>
                Nun werfen wir einen Blick auf die Kellner-Klasse, welche in unserem Beispiel als Aufrufer fungiert. Nachdem der Kunde einen konkreten Befehl erzeugt hat, kann er ihn dem Kellner in der Methode <code>bestellungEntgegennehmen(Befehl befehl)</code> übergeben. Dieser wird dann später alle Befehle ausführen lassen.
            </p>
            
            <pre><div class="code"><code>
class Kellner {

    List&lt;Befehl&gt; bestellung;

    public Kellner () {
        bestellung = new ArrayList&lt;Befehl&gt;();
    }

    void bestellungEntgegennehmen(Befehl befehl) {
        bestellung.add(befehl);
    }
    
    void bestellungAbschliessen() {
        for(Befehl b : bestellung) {
            b.ausfuehren();
        }
        bestellung.clear();
    }

} 
            </code></div></pre>
    
            <form id="commandForm">
                <h3>Zwischenprüfung</h3>
                <fieldset>
                    Was macht das Command-Pattern?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="commandA">
                                Es kontrolliert eine größere Anzahl verwandter Klassen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="commandA">
                                Es überwacht die main-Methode
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="commandA">
                                Es kapselt einen Auftrag in ein Objekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="commandA">
                                Es sortiert eine Menge von Befehlen
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Wie heißt üblicherweise die Methode, die von einer konkreten Command-Klasse implementiert werden muss?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="commandB">
                                <code>command()</code>
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="commandB">
                                <code>transfer()</code>
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="commandB">
                                <code>deploy()</code>
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="commandB">
                                <code>execute()</code>
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkCommand()" id="commandButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="commandResult"></center>
            </form>
        </div>
        
        <!-- Das Observer-Pattern -->
        <div id="observer">
            <h2>Das Observer-Pattern <a class="testjump" href="#observerForm">...direkt zum Test...</a></h2>
            
            <p class="note">
                Definition einer 1-zu-n-Abhängigkeit zwischen Objekten, damit im Fall einer Zustandsänderung eines Objekts alle davon abhängigen Objekte entsprechend benachrichtigt und automatisch aktualisiert werden.
            </p>
            
            <p>
                Werfen wir einen Blick in den Arbeitsalltag eines Kellners im <em>Ristorante BendisPasta</em>: 
            </p>
            
            <ul>
                <li>Eine Gruppe von neuen Gästen betritt das Restaurant.</li>
                <li>Der Kellner bringt die Menükarten und fragt, was er den Gästen zu trinken bringen kann.</li>
                <li>Die Gäste sagen, sie müssen noch überlegen.</li>
                <li>Die Gäste haben sich entschieden und <em>warten</em> auf den Kellner.</li>
                <li>Der Kellner kommt <em>irgendwann</em> wieder und nimmt eine Getränkebestellung entgegen.</li>
                <li>Der Kellner übermittelt die Bestellung an den Barkeeper.</li>
                <li>Der Kellner <em>wartet</em>, bis der Barkeeper die Getränke <em>irgendwann</em> eingeschenkt hat.</li>
                <li>Der Kellner serviert die Getränke und fragt, was die Gäste essen möchten.</li>
                <li>Die Gäste bitten um etwas Bedenkzeit.</li>
                <li>Die Gäste <em>warten</em> auf den Kellner.</li>
                <li><em>Irgendwann</em> kommt der Kellner wieder und nimmt die Bestellung auf.</li>
                <li>Die Bestellung wird an die Küche weitergeleitet.</li>
                <li><em>Irgendwann</em> geht der Kellner zurück zum Tisch, um Wein nachzuschenken.</li>
                <li>Die Gläser sind jedoch noch voll.</li>
                <li>Der Kellner erkundigt sich <em>irgendwann</em> in der Küche, ob schon ein Gericht servierbereit ist.</li>
                <li>Der Koch schickt ihn weg. Der Kellner <em>wartet</em>.</li>
                <li>Inzwischen ist die Bestellung zubereitet.</li>
                <li>Der Kellner kommt <em>irgendwann</em> wieder zur Küche. Das Essen ist nun nicht mehr ganz warm.</li>
                <li>Er serviert die Bestellung.</li>
                <li>...</li>
            </ul>
            
            <p>
                Zwei Wörter stechen in dieser Aufzählung besonders hervor &mdash; <em>warten</em> und <em>irgendwann</em>. Die Kellner unseres Restaurants leisten eigentlich hervorragende Arbeit, doch ihr Timing ist unter aller Sau. Während eines Arbeitstages verbringen sie einen Großteil ihrer Zeit damit zu warten oder unnötige Strecken zu laufen, weil sie nicht wissen, wann sie wo zu sein haben. Diese Vergeudung von kostbarer Arbeitszeit sollte Geschäftsführer Jens nicht weiter auf sich sitzen lassen.
            </p>
            
            <h4>Was ist zu tun?</h4>
            
            <p>
                Derzeit müssen die Kellner von <em>BendisPasta</em> einen Teil des Restaurants nach dem anderen abklappern und sich jedes Mal erkundigen, ob sie dort gerade gebraucht werden oder nicht. Umgekehrt wird ein Schuh draus: Würden die Kellner nur im Bedarfsfall zu sich gerufen, so ließe sich deren Arbeitseffizienz enorm steigern. Wir möchten daher ein neues System etablieren, in welchem die Kellner benachrichtigt werden können, sobald ein Kunde bestellen möchte bzw. sobald ein Gericht fertig zubereitet worden ist.
            </p>
            
            <h4>Die Lösung</h4>
            
            <p>
                Glücklicherweise müssen wir uns auch für dieses Problem nicht mehr den Kopf zerbrechen, denn das Observer-Pattern bietet hierfür eine praktikable Schablone. Und nicht nur das &mdash; im Package <code>java.util</code> findet sich sogar ein entsprechendes Framework, welches wir direkt einsetzen können! Dazu zählen das Interface <code>Observer</code> sowie die Klasse <code>Observable</code>.
                
            </p>
            
            <div style="display:flex; flex-wrap: wrap;">
                <div style="margin-left: auto;margin-right: auto;overflow-x: scroll;">
                <h4>Observer-API</h4>
                <pre><div class="code" style="max-width: 300px;"><code>
interface Observer {

    void update(Observable o, Object arg);
  
}
                </code></div></pre>
                </div>
                <div style="margin-left: auto;margin-right: auto;overflow-x: scroll;">
                <h4>Observable-API</h4>
                <pre><div class="code" style="max-width: 300px;" ><code>
class Observer {

    void addObserver(Observer o) {...}
    protected void clearChanged() {...}
    int countObservers() {...}
    void deleteObserver(Observer o) {...}
    void deleteObservers() {...}
    boolean hasChanged() {...}
    void notifyObservers() {...}
    void notifyObservers(Object arg) {...}
    protected void setChanged() {...}
  
}
                </code></div></pre>
                </div>
            </div>
            
            <p>
                In unserem Fall implementiert der Kellner das Interface <code>Observer</code>, damit er von den <code>Observables</code>, die er beobachtet (<em>observe</em>), benachrichtigt werden kann. Dazu muss er eine einzige Methode <code>update()</code> implementieren; sie wird später von den Observables aufgerufen, welche darin eine Referenz auf sich selbst übergeben. Auf diese Weise kann der Kellner direkt auf das Objekt zugreifen, von dem er benachrichtigt wurde:
            </p>
            
            <pre><div class="code"><code>
class Kellner implements Observer { 

    void update(Observable observable, Object arg) {
        if (observable instanceof Tisch) {
            Tisch tisch = (Tisch) observable;
            zumOrtGehen(tisch);
        } else if (observable instanceof Theke) {
            Theke theke = (Theke) observable;
            zumOrtGehen(theke);
        } ... // ggf. Abfrage weiterer in Frage kommenden Observables
    }
    
    zumOrtGehen(Ort ort) {...} // zum Restaurantteil „ort“ gehen

}
            </code></div></pre>
            
            <p>
                Unterklassen von <code>java.util.Observable</code>, die einen Observer bzw. im konkreten Fall einen Kellner benachrichtigen möchten, können dazu einfach die geerbte Methode <code>notifyObservers()</code> nutzen. Ihr Aufruf hat zur Folge, dass in allen eingetragenen Observern die Update-Methode ausgeführt wird; als Parameter wird das Observable selbst übergeben. Ein solches Observable könnte ein Objekt der (hier nicht genauer spezifizierten) Klasse <code>Tisch</code> sein:
            </p>

            <pre><div class="code"><code>
class Tisch extends Observable implements Ort {
    
    ... // diverse Klassenvariablen für Tischnummer, Standort, Bestellung o. Ä.
    
    public Tisch() {}
    
    ... // diverse Methoden
    
    // Wann immer an einem Tisch etwas benötigt wird, wird diese Funktion aufgerufen
    void statusAenderung() {
        setChanged();
        notifyObservers(); // Kellner und sonstige Observer benachrichtigen
    }
}
            </code></div></pre>

            <form id="observerForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Wozu dient das Observer-Muster?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="observerA">
                                Vermeidung von zeitgleichen Objektzugriffen bei nebenläufigen Anwendungen
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="observerA">
                                Effizienteres Pair-Programming
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="observerA">
                                Kontrolle der Nutzung von Variablentypen
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="observerA">
                                Objekte über Änderungen in einem anderen Objekt auf dem Laufenden halten
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welche Aussage stimmt nicht?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerB1">
                                Ein Observable kann mehrere Observer registrieren
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="observerB2">
                                Ein Observer-Objekt kann sich in mehreren Obervables registrieren
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerB3">
                                <code>java.util.Observable </code> ist ein Interface
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="observerB4">
                                <code>java.util.Observer </code> ist eine abstrakte Klasse
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Vervollständige das folgende Klassengerüst.
                </fieldset>
                <pre><div class="code"><code>
class Theke <input type="text" value = "extends" style="width: 7ch;font-weight: bold; color: rgb(0,85,153);" name="observerC1"> <input type="text" value = "Observable" style="width: 10ch;font-weight: bold; color: rgb(44,0,159);" name="observerC2"> {

    boolean bestellungAbholbereit = false;
    
    public Theke() {...}
    
    /* Diese Methode wird aufgerufen, nachdem alle Getränke einer Bestellug eingeschänkt wurden.
     * Sie wird erneut aufgerufen, sobald diese abgeholt worden sind. */
    void abholstatusAendern() {
        bestellungAbholbereit = <input type="text" value = "!bestellungAbholbereit" style="width: 22ch;" name="observerC3">; // Abholstatus umkehren
        statusAenderung();
    }
    
    void statusAenderung() {
        setChanged();
        <input type="text" value = "notifyObservers()" style="width: 17ch;" name="observerC4">; // Kellner und sonstige Observer benachrichtigen
    }
    
}
                </code></div></pre>
                <button type="button" onclick="checkObserver()" id="observerButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="observerResult"></center>
            </form>
        
        </div>
        
        <!-- Das Factory-Pattern -->
        <div id="factory">
            <h2>Das Factory Method-Pattern <a class="testjump" href="#factoryForm">...direkt zum Test...</a></h2>
            
            <p class="note">
                Zur „Definition einer Schnittstelle zur Objekterzeugung, wobei die Bestimmung der zu instanziierenden Klasse den Unterklassen überlassen bleibt. Das Design Pattern Factory Method (Fabrikmethode) gestattet einer Klasse, die Instanziierung an Unterklassen zu delegieren.“ [GoF]
            </p>
            
            <p>
                Bislang war es so, dass der Kunde zunächst wissen musste, wie er ein bestimmtes Gericht erzeugt, ehe er dieses in Form einer <code>GerichteBestellung</code> in Auftrag geben konnte. Eigentlich ist das nicht die Aufgabe des Kunden und sollte ein Geheimnis der Küche bleiben. Der Kunde hat eine Menükarte, in dem die einzelnen Gerichte mit Nummern versehen aufgelistet sind. Wir möchten daher unsere Befehls-Klassen dahingehend ändern, dass die Zuständigkeit der Gericht-Instanziierung nicht mehr beim Kunden liegt.
            </p>
            
            <h4>Was ist zu tun?</h4>
            
            <p>
                Anstelle konkreter Menü-Objekte, wollen wir den Befehlsklassen in Zukunft die entsprechenden Nummern aus der Karte übergeben. Die neue <code>GerichteBestellung</code>-Klasse könnte in etwa so aussehen:
            </p>
            

            <pre><div class="code"><code>
class GerichteBestellung implements Befehl {

    Gericht gericht;

    public GerichteBestellung(int gerichtID) {

        if(gerichtID == 1) {
            gericht = new InsalataMista();
        } else if (gerichtID == 2) {
            gericht = new InsalataCapricciosa();
        }

        ...

        else if (gerichtID == 35) {
            gericht = new PizzaMargherita();
        } else if (gerichtID == 36) {
            gericht = new PizzaCipolla();
        } else if (gerichtID == 37) {
            gericht = new PizzaCalzone();
        }

        ...

        else if (gerichtID == 68) {
            gericht = new PenneAllArrabiata();
        }

        ...

    }

    void ausführen() {
        gericht.zubereiten();
        gericht.servieren();
    }

}
            </code></div></pre>
            
            <p>
                Wie du vielleicht schon erkannt hast, ist diese Art der Implementierung eher nicht zu empfehlen. Sie macht Änderungen der Menükarte enorm umständlich und sie bürdet der Befehlsklasse eine Rolle auf, für die sie eigentlich nicht gedacht ist. Besser wäre es, die Instanziierung der einzelnen Gerichte in eine eigens dafür geschaffene Klasse auszulagern. 
            </p>

            <h4>Die Lösung</h4>
            <p>
                Das Factory Method-Pattern empfiehlt uns genau das. Wir erstellen eine neue Klasse <code>GerichteFabrik</code>, die eine Methode zur Erzeugung von Gerichten bereitstellt: <code>erzeugeGericht()</code>. Wie genau diese Methode implementiert wird, interessiert uns dabei erstmal nicht. Dies kann wie im vorigen Beispiel anhand einer Menge von if- bzw. case-Abfragen geschehen, mithilfe einer inneren bzw. globalen Speisekarten-Klasse oder auf der Grundlage sonstiger geeigneter Datenstrukturen. Entscheidend ist, dass wir unsere Klassenstruktur allein durch die Auslagerung schon erheblich verbessert haben. Zudem kann die Gerichtefabrik nun zur Laufzeit ausgetauscht werden.
            </p>

            <h4>Neuer Code</h4>
            <pre><div class="code"><code>
class GerichteBestellung implements Befehl{

    Gericht gericht;
    GerichteFabrik fabrik;

    public GerichteBestellung(int gerichtID) {
        fabrik = new StandardGerichteFabrik();
        gericht = fabrik.erzeugeGericht(gerichtID);
    }

    void ausfuehren() {
        gericht.zubereiten();
        gericht.servieren();
    }
    
    void setFabrik(GerichteFabrik fabrik) {
        this.fabrik = fabrik;
    }
    
}
            </code></div></pre>


            <form id="factoryForm">
                <h3>Zwischenprüfung</h3>
                <fieldset>
                    Was ist die wesentliche Aufgabe der Fabrikmethode?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="factoryA">
                                Erstellen von Objekt-Kopien
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="factoryA">
                                Instanziieren von Objekten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="factoryA">
                                Einer Variable Initialwerte zuweisen
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="factoryA">
                                Überschreiben eines Konstruktors
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Welche Aussagen treffen auf das Factory Method-Muster zu?
                    <ul>
                        <li> 
                            <label>
                                <input type="checkbox" name="factoryB1">
                                Es fördert die Kapselung
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="checkbox" name="factoryB2">
                                Die Objekterzeugung wird ausgelagert
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="factoryB3">
                                Durch die zusätzliche Factory-Klasse erhöht sich die Gesamtanzahl an Klassen in einem Projekt
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="checkbox" name="factoryB4">
                                Eine Factory-Klasse kann keine weiteren Unterklassen haben
                            </label>
                        </li>
                    </ul> 
                </fieldset> 
                <br/>
                <fieldset>
                    Ergänze das untenstehende Gerüst für unsere GerichteFabrik.
                </fieldset>
                <pre><div class="code"><code>
class GerichteFabrik {

    public GerichteFabrik() {}
    
    // Fabrikmethode
    <input type="text" value="Gericht" style="width: 7ch;" name="factoryC1"> <input type="text" value="erzeugeGericht" style="width: 14ch;color: rgb(44,0,159);font-weight: bold;" name="factoryC2">(<input type="text" value="int" style="width: 3ch;color: rgb(0,85,153);font-weight: bold;" name="factoryC3"> gerichtID) { // Rückgabetyp, Methodennamen und Parametertyp eintragen
        ... // beliebige Implementierung (nichts zu ergänzen)
    }

}
                </code></div></pre>
                <button type="button" onclick="checkFactory()" id="factoryButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="factoryResult"></center>
            </form>
        </div>
        
        <!-- Das Strategy-Pattern -->
        <div id="strategy">
            <h2>Das Strategy-Pattern <a class="testjump" href="#strategyForm">...direkt zum Test...</a></h2>
            
            <p class="note">
                Zur „Definition einer Familie von einzeln gekapselten, austauschbaren Algorithmen. Das Design Pattern Strategy (Strategie) ermöglicht eine variable und von den Clients unabhängige Nutzung des Algorithmus.“ [GoF]
            </p>
            
            <p>
                Die Pizzeria <em>BendisPasta</em> legt viel Wert auf ein vielseitiges und abwechslungsreiches Angebot. Aus diesem Grund müssen die Gerichte der Karte je nach Saison und Koch auf unterschiedliche Weise zubereitet werden. So soll auch die Pizza nicht nur nach klassisch italienischer Rezeptur, sondern auch auf amerikanischer Art gebacken werden können. Zudem will man sich offen halten, noch weitere Rezepturen und Variationen anbieten und bestehende Rezepte jederzeit ändern zu können.
            </p>
            
            <h4>Was ist zu tun?</h4>
            
            <p>
                Derzeit ist die Methode <code>zubereiten()</code> in den konkreten Gerichte-Klassen der einzige Ort, an dem die einzelnen Schritte einer Rezeptur spezifiziert, d. h. implementiert sind. Wenn wir also eine Pizza Margherita nicht auf italienische, sondern auf amerikanische Art zubereiten wollen, so müssten wir dazu die gesamte Methode <code>zubereiten()</code> in der Klasse <code>PizzaMargherita</code> überschreiben. Wir sind nun auf der Suche nach einer Möglichkeit, um den darin enthaltenen Code flexibel austauschen zu können.
            </p>
            
            <h4>Die Lösung</h4>
            
            <p>
                Hier kommt uns das Strategy-Pattern wie gerufen. Dieses empfiehlt uns, die unterschiedlichen Zubereitungsarten in eigene Klassen zu kapseln und die gewünschte Zubereitungsart in einer Klassenvariable unseres Gerichtes zu speichern. Der Algorithmus zum Zubereiten der Pizza ist dann nicht mehr in der Pizza-Klasse selbst implementiert, stattdessen wird er über den Zugriff auf die darin gespeicherte Zubereitungsart aufgerufen. Wir erstellen also zunächst ein neues Interface, welches wir <code>Zubereitungsart</code> nennen:
            </p>


            <pre><div class="code"><code>
interface Zubereitungsart {

    void zubereiten(String[] zutaten);

}
            </code></div></pre>
            
            <p>
                Eine konkrete Zubereitungsart wäre z. B. <code>ItalienischeZubereitungsart</code>:
            </p>
            
            <pre><div class="code"><code>
class ItalienischeZubereitungsart implements Zubereitungsart {

    void zubereiten(String[] zutaten) {
        ... // Pizza mit den gegebenen Zutaten auf italienische Art zubereiten
    }

}
            </code></div></pre>
            
            <p>
                Unser neues Interface hat eine einzige Methode, für die es geschaffen wurde: <code>zubereiten(String[] zutaten)</code>. In unserer abstrakten Pizza-Klasse fügen wir nun die neue Klassenvariable <code>zubereitungsart</code> hinzu und ergänzen die Möglichkeit die gewünschte Zubereitungsart schon im Konstruktor zu spezifizieren:
            </p>
            
            <pre><div class="code"><code>
abstract class Pizza implements Gericht {

    String[] zutaten;
    Zubereitungsart zubereitungsart;
    
    public Pizza() {}
    
    public Pizza(Zubereitungsart zubereitungsart) {
        this.zubereitungsart = zubereitungsart;
    }

    abstract void zubereiten();

}
            </code></div></pre>
            
            <p>
                So könnte dann eine konkrete Klasse vom Typ Pizza aussehen:
            </p>
            
            <pre><div class="code"><code>
class PizzaMargherita extends Pizza {

    public PizzaMargherita() {
    
        this.zubereitungsart = new ItalienischeZubereitungsart(); // Standard-Zubereitungsart
        zutaten = {"Tomatensauce", "Mozarella"};

    }
    
    public PizzaMargherita(Zubereitungsart zubereitungsart) {
        this.zubereitungsart = zubereitungsart;
        zutaten = {"Tomatensauce", "Mozarella"};       
    }
    
    void zubereiten() {
        zubereitungsart.zubereiten(zutaten);
    }

}
            </code></div></pre>
            
            <p>
                Nun können wir Pizzen flexibel mit unterschiedlichen Zubereitungsarten erzeugen. Mithilfe einer Setter-methode &mdash; <code>setZubereitungsart()</code> &mdash; könnten wir die Zubereitungsart sogar zur Laufzeit ändern. Wird eine Zubereitungsart bearbeitet, so werden die Änderungen von allen Gerichteklassen, die diese Zubereitungsart verwenden, automatisch übernommen. Wie du siehst, bietet das Strategy-Pattern eine ganze Reihe von Vorteilen.
            </p>
            
            <form id="strategyForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Was ist die wesentliche Motivation des Strategy-Ansatzes?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="strategyA">
                                Einen konkreten Algorithmus möglichst effizient gestalten
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="strategyA">
                                Die Menge an Klassenvariablen minimieren
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="strategyA">
                                Den vorrangigen Zweck eines Projektes stets im Auge behalten
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="strategyA">
                                Algorithmen bzw. Methoden einer Klasse leichter austauschbar halten
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <fieldset>
                    Ergänze das Gerüst für eine neue Zubereitungsart <code>AmerikanischeZubereitungsart</code>
                </fieldset>
                <pre><div class="code"><code>
class <input type="text" value = "AmerikanischeZubereitungsart" style="width: 28ch;font-weight: bold; color: rgb(44,0,159);" name="strategyC1"> <input type="text" value = "implements" style="width: 10ch;font-weight: bold; color: rgb(0,85,153);" name="strategyC2"> <input type="text" value = "Zubereitungsart" style="width: 15ch;font-weight: bold; color: rgb(44,0,159);" name="strategyC3"> {
    
    <input type="text" value="void" style="width: 4ch;font-weight: bold; color: rgb(0,85,153);" name="strategyC4"> <input type="text" value="zubereiten" style="width: 10ch;color: rgb(44,0,159);font-weight: bold;" name="strategyC5">(<input type="text" value="String[]" style="width: 8ch;" name="strategyC6"> zutaten) { // Rückgabetyp, Methodennamen und Parametertyp eintragen
        ... // Pizza mit den gegebenen Zutaten auf amerikanische Art zubereiten
    }
    
}
                </code></div></pre>
                <button type="button" onclick="checkStrategy()" id="strategyButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="strategyResult"></center>
            </form>
        </div>
        
        <!-- Das Decorator-Pattern -->
        <div id="decorator">
            <h2>Das Decorator-Pattern <a class="testjump" href="#decoratorForm">...direkt zum Test...</a></h2>
            
            <p class="note">
                Zur „dynamische[n] Erweiterung der Funktionalität eines Objekts. Decorator-Objekte stellen hinsichtlich der Ergänzung einer Klasse um weitere Zuständigkeiten eine flexible Alternative zur Unterklassenbildung dar.“ [GoF]
            </p>
            
            <p>
                Als nächstes möchten wir den Kunden von <em>BendisPasta</em> die Möglichkeit bieten, ihren Gerichten  eine Garnitur hinzuzufügen. So soll es für alle Pizzen die Option geben, sie u. A. mit Knoblauch, Oregano oder scharfer Sauce serviert zu bekommen. Hier sehen wir einen ersten Vorschlag, diesem Wunsch zu entsprechen &mdash; durch Bildung weiterer Unterklassen:
            </p>

            <pre><div class="code"><code>
class PizzaMargheritaMitKnoblauch extends PizzaMargherita {...}

class PizzaMargheritaMitOregano extends PizzaMargherita {...}

class PizzaMargheritaMitScharferSauce extends PizzaMargherita {...}

class PizzaMargheritaMitOreganoUndKnoblauch extends PizzaMargherita {...}

class PizzaMargheritaMitKnoblauchUndScharferSauce extends PizzaMargherita {...}

class PizzaMargheritaMitOreganoUndScharferSauce extends PizzaMargherita {...}

class PizzaMargheritaMitKnoblauchUndOreganoUndScharferSauce extends PizzaMargherita {...}

            </code></div></pre>
            
            <p>
                Es ist wohl recht offensichtlich, dass das nicht der richtige Weg sein kann. Mit jeder zusätzlichen Garnitur im Angebot würde sich die Menge an Unterklassen verdoppeln. Zudem müsste für jedes konkrte Gericht eine eigene Menge solcher Unterklassen erstellt werden. Früher oder später würde das in einem einzigen Chaos enden.
            </p>
                
            <h4>Was ist zu tun?</h4>
            
            <p>
                Wir suchen eine einfache und saubere Möglichkeit, unseren konkreten Gerichten optionale Eigenschaften hinzuzufügen. Weitere Unterklassen dieser Gerichte sind, wie wir gesehen haben, für uns keine Option. Besser wäre es, für jede Garnitur eine eigene Klasse vom Typ <code>Garnitur</code> zu bilden und diese den Gerichten irgendwie als optionale Eigenschaft beizufügen. Der intuitive Ansatz bestünde wohl darin, die Gerichte-Klasse um neue Klassenvariablen zu ergänzen, in denen die verschiedenen Garnituren hinterlegt werden können. Doch mit dem Decorator-Pattern haben wir ein Muster zur Hand, dass unser Problem auf bewährte Art und Weise, doch etwas anders angeht.
            </p>
                
            <h4>Die Lösung</h4>
            
            <p>
                Dreh- und Angelpunkt unseres neuen Patterns ist eine abstrakte Decorator-Klasse, die wir in unserem Fall Garnitur nennen. Dazu hier ein Beispiel, wie wir das Decorator-Pattern zum Würzen unserer Pizzen nutzen können:
            </p>

            <pre><div class="code"><code>
abstract class PizzaGarnitur extends Pizza {

    float preis;
    Pizza pizza;
    
    abstract void zubereiten();
    
    void servieren() {
        pizza.servieren();
    };
    
    int preis() {
        return pizza.preis() + this.preis; 
    }

}
            </code></div></pre>
            
            <p>
                Unsere neue Klasse <code>PizzaGarnitur</code> erweitert die abstrakte Klasse <code>Pizza</code> &mdash; sie ist damit sozusagen selbst eine Pizza. Der Konstruktor erwartet allerdings im Übergabeparameter die „echte“ Pizza, welche dann in der Klassenvariable <code>pizza</code> gesichert wird. Für jede Methode, die eine Klasse vom Typ <code>Pizza</code> bereitstellen muss, ruft die Klasse vom Typ <code>GerichteGarnitur</code> die entsprechende Methode per Zugriff auf das gespeicherte Pizza-Objekt auf. Im Fall von Knoblauch sieht das dann in etwa so aus:
            </p>
            
            <pre><div class="code"><code>
class Knoblauch extends PizzaGarnitur {
    
    public Knoblauch(Pizza pizza) {
        this.pizza = pizza;
        this.preis = 0.5;
    }

    void zubereiten() {
        pizza.zubereiten();
        ... // mit Knoblauch garnieren
    }
  
}
            </code></div></pre>
            
            <p>
                Wenn wir nun eine Pizza Margherita mit Knoblauch erzeugen möchten, so geschieht dies einfach durch die Anweisung <code>Pizza meinePizza = new Knoblauch(new PizzaMargherita)</code>. Möchten wir außerdem Oregano dazu, so wäre folgende Anweisung ebenfalls möglich: <code>meinePizza = new Oregano(meinePizza)</code>. Für Restaurantgäste ohne Begleitung bestünde sogar die Option eine Pizza mit doppelt Knoblauch zu bekommen: <code>meinePizza = new Knoblauch(new Knoblauch(new PizzaMargherita))</code>.
            </p>
            


            <form id="decoratorForm">
                <h3>Multiple Choice-Test</h3>
                <fieldset>
                    Worin besteht die wesentliche Aufgabe eines Decorators?
                    <ul>
                        <li> 
                            <label>
                                <input type="radio" name="decoratorA">
                                Erweitern eines Objektes
                            </label>
                        </li>
                        <li> 
                            <label>
                                <input type="radio" name="decoratorA">
                                Verschönern der Klassenstruktur
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="decoratorA">
                                Sammeln von Funktionen ohne Rückgabewert
                            </label>
                        </li>
                        <li>  
                            <label>
                                <input type="radio" name="decoratorA">
                                Verbesserung der Fabrikmethode
                            </label>
                        </li>
                    </ul> 
                </fieldset>
                <br/>
                <button type="button" onclick="checkDecorator()" id="decoratorButton">Auswerten</button>&nbsp;&nbsp;&nbsp;&nbsp;<center id="decoratorResult"></center>
            </form>
        </div>
        
        <!-- Der Model-View-Controller -->
        <div id="mvc">
            <h2>Der Model-View-Controller <a class="testjump" href="#mvcForm">...direkt zum Test...</a></h2>
        </div>
        
        <p class="note">
            „Zur Unterteilung einer Software in die drei Komponenten Datenmodell (<em>model</em>), Präsentation (<em>view</em>) und Programmsteuerung (<em>controller</em>). [...] Ziel des Musters ist ein flexibler Programmentwurf, der eine spätere Änderung oder Erweiterung erleichtert und eine Wiederverwendbarkeit der einzelnen Komponenten ermöglicht.“ [<a target="_blank" style="text-decoration: none; color: #545454;" href="https://de.wikipedia.org/w/index.php?title=Model_View_Controller&oldid=185257654" >Wikipedia</a>]
        </p>
        
        <div id="literature">
            <h2>Weiterführende Literatur</h2>
            <ul>
                <li>Freeman, Eric und Elisabeth Robson (2015). <em>Entwurfsmuster von Kopf bis Fuß</em></li>
                <li> [GoF] Gamma, Erich u. a. (2015). <em>Design Patterns. Entwurfsmuster als Elemente wiederverwendbarer
                    objektorientierter Software</em></li>
            </ul>
        </div>
    </body>
    
    <!-- Lösungen anzeigen -->
    <script>solveAll();</script>
</html>
